<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>IP-адреса, structы, и обработка данных</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="theory.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="ip4to6.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>


<h2 class="sect1title">3. <a name="ipstructsdata">IP-адреса, <nobr><b><tt class="titletype">struct</tt></b></nobr>ы, и обработка данных</a></h2><hr class="mainsecthr"/>


<p>В этом разделе мы дошли до той части игры, где мы что-то покодим для разнообразия.</p>

<p>Но для начала, давайте ещё обсудим кое-что без кода! Во-первых, я хочу немного рассказать о <a name="indexId434909-57"></a>IP-адресах и портах, чтобы всё было по порядку. Далее, мы обсудим, как API сокетов хранит и управляет IP-адресами и другими данными.</p>



<h3 class="sect2title">3.1. <a name="ipaddrs1">IP-адреса, версии 4 и 6</a></h3>


<p>В старые добрые времена, когда Бена Кеноби всё ещё звали Оби Ваном Кеноби, существовала превосходная система маршрутизации под названием Интернет протокол, версия 4, также известная как <a name="indexId434909-58"></a>IPv4.  В ней были адреса, состоящие из 4 байт(A.K.A. 4х "октетов"), которые обычно записывались в форме "чисел и точек", как, например: <tt class="tt">192.0.2.111</tt>.</p>

<p>Возможно, ты уже видел такую запись.</p>

<p>На деле, на момент написания этой статьи, виртуально каждый сайт в интернете использует адреса IPv4.</p>

<p>Все, включая Оби Вана, были счастливы. И всё было хорошо, до тех пор, пока один пророк по имени Vint Cerf не предупредил всех, что скоро IPv4 закончатся!</p>

<p>(Помимо предупреждения всех о приближающемся IPv4-апокалипсисе Рока и Мрака, <a name="indexId434909-59"></a><a href="http://en.wikipedia.org/wiki/Vinton_Cerf" target="_blank">Vint Cerf</a> также хорошо известен как Отец Интернета. Поэтому я вряд ли вправе критиковать его суждения.)</p>

<p>Закончатся адреса? Да как это вообще возможно? В смысле, существуют миллиарды 32-битных IPv4 IP-адресов. У нас что, серьёзно есть миллиарды компьютеров?</p>

<p>Ага.</p>

<p>Кроме того, в самом начале, когда компьютеров было довольно мало и миллиард казался недостижимо великим числом, некоторые большие организации щедро зарезервировали миллионы IP-адресов для своего использования. (Например, Xerox, MIT, Ford, HP, IBM, GE, AT&amp;T, и одна маленькая компания под названием Apple - и это всего несколько примеров.)</p>

<p>На самом деле, если бы некоторые экстренные меры не были бы приняты, они бы закончились давным-давно.</p>

<p>Но сейчас мы живём в мире, где почти каждый человек имеет свой IP-адрес, каждый компьютер, каждый калькулятор, каждый телефон, каждый счётчик на автостоянке и каждый (а почему бы и нет?) маленький щеночек может иметь свой IP.</p>

<p>И поэтому был создан <a name="indexId434909-60"></a>IPv6. Поскольку, Vint Cerf, возможно,  бессмертен (даже если его физическая оболочка, не дай бог, прекратит существовать, возможно он уже приготовил себе что-то вроде гипер-интеллектуальной программы <a href="http://en.wikipedia.org/wiki/ELIZA" target="_blank">ELIZA</a> в глубинах Интернета2), никто не хочет снова услышать от него "Ну я же говорил" если вдруг у нас закончатся адреса и в следующей версии IP-протокола.</p>

<p>К чему же это нас приводит?</p>

<p>А к тому, что нам нужно <i>намного</i> больше адресов. Что нам нужно не просто в два раза больше, не в миллиард раз больше и не в тысячу триллионов раз больше, а в <i>79 МИЛЛИОНОВ МИЛЛИАРДОВ ТРИЛЛИОНОВ больше возможных адресов!</i>  Тогда точно всем хватит!</p>

<p>Ты сейчас говоришь, "Beej, это что, правда? У меня есть куча причин, чтобы не верить гигантским числам." Ну, разница между 32 и 128 битами возможно звучит как не слишком большая; всего на 96 бит больше, чего там, правда? Но, поскольку, в этом случае мы говорим о степенях: если 32 бита представляют примерно 4 миллиарда чисел (2<sup><small>32</small></sup>), то 128 бит представляют примерно 340 триллионов триллионов триллионов (2<sup><small>128</small></sup>, всё как есть). Это как миллион IPv4 - интернетов для <i>каждой звезды во Вселенной</i>.</p>

<p>Также, забудь о точках-и-числах в написании IPv4; теперь у нас будет шестнадцатеричное представление, при этом каждый двухбайтовый кусок будет разделён двоеточием, например так: <tt class="tt">2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551</tt>.</p>

<p>И это ещё не всё! Довольно часто, если у тебя есть IP-адрес с кучей нулей в нём, ты можешь сжать его в некоторых местах, выкинув лидирующие нули. Например, каждая из этих пар адресов равнозначна:</p>

<pre class="screen">2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</pre>


<p>Адрес <tt class="tt">::1</tt> называется <i>loopback-адресом</i>. Он всегда означает "машина, на которой я запущен в данный момент". В IPv4, loopback-адресом является 127.0.0.1.</p>

<p>И наконец, существует режим совместимости с IPv4 для IPv6 - адресов. Если ты, к примеру, хочешь представить IPv4-адрес 192.0.2.33 как IPv6, то это будет выглядеть так:
"<tt class="tt">::ffff:192.0.2.33</tt>".</p>

<p>Мы говорим о реально крутой штуке.</p>

<p>На самом деле, это настолько крутая штука, что Творцы IPv6 просто взяли и зарезервировали триллионы и триллионы адресов, но у нас их так много, что кто вообще будет считать? Ещё с избытком осталось для каждого мужчины, женщины, ребёнка, щеночка и счётчика на автостоянке для каждой планеты в галактике. И поверь мне, на каждой планете в галактике есть автостоянки и счётчики на них. Ты и сам знаешь, что так оно и есть.</p>



<h4 class="sect3title">3.1.1. <a name="netslash">Подсети</a></h4>


<p>По организационным причинам, иногда имеет смысл объявить, что "первая часть IP-адреса, до такого-то бита - это <i>адрес сети</i>, а оставшееся - <i>адрес хоста</i>.</p>

<p>К примеру, в IPv4, у тебя может быть адрес <tt class="tt">192.0.2.12</tt>, и мы можем сказать, что первые три байта этого адреса - это адрес сети, а оставшийся представляет собой адрес хоста. Или, другими словами, этот адрес представляет собой хост номер <tt class="tt">12</tt> в сети под номером <tt class="tt">192.0.2.0</tt> (обрати внимание, как мы обнулили байт, представляющий хост.)</p>

<p>А теперь вернёммся к более устаревшей информации! Готов? В Древние Времена сущестовали "классы" подсетей, в которых первые один, два или три байта были адресом сети. Если ты был достаточно удачлив, чтобы заполучить сеть, в которой первый байт отвечает за номер сети, и три оставшихся - за номер хоста, то у тебя была возможность подключить к своей сети около 24 миллионов компьютеров. Это называлось сетью "класса А". С другой стороны были сети "класса С", с тремя байтами на адрес сети и одним - на адрес хоста(итого только 256 хостов, минус некоторые зарезервированные.)</p>

<p>Таким образом, у нас было совсем немного сетей класса А, целая куча сетей класса С и прилично сетей класса В посередине.</p>

<p>Часть адреса, представляющая сеть описывается штукой, которая называется <i>маской подсети</i>, с которой нужно произвести побитовое И с IP-адресом, чтобы вычленить из него номер сети. Обычно маска подсети выглядит примерно так: <tt class="tt">255.255.255.0</tt>.  (Например, с такой маской, если твой IP - <tt class="tt">192.0.2.12</tt>, то твоя сеть - <tt class="tt">192.0.2.12</tt> & <tt class="tt">255.255.255.0</tt>, что даёт нам <tt class="tt">192.0.2.0</tt>.)</p>

<p>К сожалени, быстро выяснилось, что такая классификация недостаточно гибка: сети класса С закончились довольно быстро, не говоря уже о сетях класса А. Чтобы исправить это, Высшие Силы разрешили маске подсети быть любым числом бит, а не только 8, 16 или 24. Таким образом, у тебя может быть маска, скажем <tt class="tt">255.255.255.252</tt>, что означает - 30 бит на адрес сети и два бита на хост, то есть 4 возможных хоста. (Обрати внимание, что маска подсети это <i>ВСЕГДА</i> несколько единиц, за которыми следуют несколько нулей.)</p>

<p>Но, использовать битовую строку, например <tt class="tt">255.192.0.0</tt> в качестве маски подсети довольно неудобно. Во первых, так сразу и не сообразишь, сколько же там единиц и во вторых, такая запись совершенно не компактная. И тогда появился Новый Стиль и он был гораздо более удобен. Теперь нужно было лишь поставить слэш после IP-адреса и написать после него количество единиц в маске подсети. Например, так: <tt class="tt">192.0.2.12/30</tt>.</p>

<p>Или, в IPv6, это бы выглядело как-то так: <tt class="tt">2001:db8::/32</tt> или
<tt class="tt">2001:db8:5413:4028::9db9/64</tt>.</p>





<h4 class="sect3title">3.1.2. <a name="portnums">Порты</a></h4>


<p>Если ты помнишь, я рассказывал тебе ранее о <a href="theory.html#lowlevel">Сетевой Модели ISO(Layered Network Model)</a>, в которой уровень Интернета (IP) был отделён от Транспортного уровня Компьютер-Компьютер(TCP и UDP). Это пригодится нам в следующем абзаце.</p>

<p>Похоже, что помимо IP-адреса (используемого уровнем Интернета(IP layer), существует также другой адрес, используемый TCP (потоковыми сокетами) и, так уж получилось, UDP (датаграм-сокетами). Это <i>номер порта</i>. Это 16-битное число, которое можно интерпретировать примерно как "локальный адрес соединения".</p>

<p>IP-адрес можно сравнить с адресом отеля, в то время как номер порта - с номером комнаты в нём. Это вполне подходящая аналогия; возможно, позже я расскажу ещё об одной, связанной с автомобилями.</p>

<p>Допустим, тебе нужен компьютер, который должен управлять входящей почтой и веб-сервисами - как ты отличишь, к чему относится пришедший пакет, если он пришёл на один IP-адрес?</p>

<p>Так вот, для это разные типы сервисов в интернете имеют разные общепринятые номера портов. Все общепринятые порты можно посмотреть в <a href="http://www.iana.org/assignments/port-numbers" target="_blank">Большом Списке Портов IANA</a> или, если ты используешь Unix, в файле <i><tt class="var">/etc/services</tt></i>.  HTTP (собственно, веб) - порт 80, telnet - 23, SMTP - 25, игра <a href="http://en.wikipedia.org/wiki/Doom_(video_game)" target="_blank">DOOM</a> использует порт 666 и т.д. и т.п. Почти все порты до 1024 - зарезервированы и довольно часто требуют специальных привилегий в системе, чтобы их использовать.</p>

<p>Вот и всё о портах!</p>

 

 



<h3 class="sect2title">3.2. <a name="byteorder">Порядок Байтов</a></h3>


<p><a name="indexId434909-61"></a>Приказ Короля! Должно быть два порядка байт, называемых далее как Убогий и Великолепный!</p>

<p>Я шучу, но один из них действительно лучше другого.  <tt>:-)</tt></p>

<p>Не так-то просто сказать это, поэтому я просто выпалю: твой компьютер может тайно хранить байты в обратном порядке! Это тщательно скрываемая правда!</p>

<p>Вещь, с которой в основном согласны все люди в Интернете: если тебе нужно представить, скажем, двухбайтовое шестнадцатеричное число, например 
<tt class="tt">b34f</tt>, ты будешь хранить его в двух последовательных байтах: <tt class="tt">b3</tt>, а за ним <tt class="tt">4f</tt>. Вроде логично, и, по словам <a href="http://en.wikipedia.org/wiki/Wilford_Brimley" target="_blank">Wilford'a Brimley</a>, так оно и должно быть. Такой порядок, в котором большие разряды идут впереди, называется <i>Big-Endian</i>.</p>

<p>К сожалению, есть несколько разбросанных по всему миру компьютеров, обычно с процессорами от Intel, или Intel-совместимыми, в которых байты хранятся в обратном порядке, поэтому <tt class="tt">b34f</tt> будет храниться в памяти какдва последовательных байта: <tt class="tt">4f</tt>, а за ним <tt class="tt">b3</tt>. Такой метод хранения называется <i>Little-Endian</i>.</p>

<p>Но погоди, я ещё не закончил с терминологией! Обычно <i>Big-Endian</i> ещё называют <i>Сетевым Порядком Байт(Network Byte Order)</i>, потому что именно так передаются байты по сети.</p>

<p>Твой компьютер хранит числа в <i>Порядке Байтов Хоста</i>. Если это Intel 80x86, то порядок - Little-Endian. Если это Motorola 68k, то порядок -  Big-Endian. Если это PowerPC, то порядок байт зависит от модели!</p>

<p>Очень часто, когда ты создаёшь пакеты или заполняешь структуры данных, тебе нужно быть уверенным, что твои двух- и четырёх- байтовые числа записаны в Сетевом Порядке байт. Но как можно добиться этого, если ты не знаешь порядок байт на твоей машине?</p>

<p>У меня для тебя хорошие новости! Тебе просто нужно предположить, что порядок данных на твоём компьютере не тот и отдать своё значение специальной функции, которая приведёт его к нужному порядку. Функция сама выполнит магическую конвертацию, если это было необходимо, и тогда твой код будет переносим на машины с другим порядком байт.</p>

<p>Отлично. Есть два типа чисел, которые ты можешь конвертировать: <nobr><tt class="type">short</tt></nobr> (два байта) и <nobr><tt class="type">long</tt></nobr> (4 байта). Эти функции также работают для беззнаковых(<nobr><tt class="type"></tt></nobr>) вариантов этих типов. Предположим, ты хочешь конвертировать  <nobr><tt class="type">short</tt></nobr> из Локального Порядка Байт в Сетевой. Начнём с "h"  - как "host", далее "to", потом "n"("network"), и "s", т.к. "short": h-to-n-s, или <b><tt class="func">htons()</tt></b> (читается как: "Host to Network Short").</p>

<p>Это даже слишком просто...</p>

<p>Ты можешь использовать любую комбинацию из "n", "h", "s", and "l", какую тебе хочется, не считая безумных. К примеру, не существует функции <b><tt class="func">stolh()</tt></b> ("Short to Long Host") — по крайней мере, в этом наборе. Но есть такие функции, как:</p>

<p>
<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="20%%"><p><a name="indexId434909-62"></a><b><tt class="func">htons()</tt></b></p></td>
<td valign="top" align="left" width="78%%"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-63"></a><b><tt class="func">htonl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">l</tt></b>ong</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-64"></a><b><tt class="func">ntohs()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-65"></a><b><tt class="func">ntohl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">l</tt></b>ong</p></td>
</tr>

</table></center>

</p>

<p>Логично, что тебе нужно сконвертировать числа в Сетевой Порядок Байтов перед тем, как послать их по сети, а потом конвертировать их в Порядок Байтов Хоста, когда они придут к получателю.</p>

<p>К сожалению, я не знаю 64-битного вариаанта. И да, если тебе нужно передать число с плавающей точкой, обратись к секции <a href="advanced.html#serialization">Сериализация</a>, ниже.</p>

<p>Можешь считать, что числа в этом документе находятся в Порядке Байтов Хоста, если я не укажу иное.</p>

 



<h3 class="sect2title">3.3. <a name="structs"><nobr><b><tt class="titletype">struct</tt></b></nobr>ы</a></h3>


<p>Ну, наконец-то добрались. Пришло время поговорить о программировании. В этом разделе я расскажу а различных типах данных, используемых сокетами, посколько некоторые из них не так-то просто понять.</p>

<p>Первый тип данных простой: <a name="indexId434909-66"></a>дескриптор сокета. Дескриптор сокета имеет следующий тип:</p>

<pre class="code">int</pre>


<p>Самый обыкновенный <nobr><tt class="type">int</tt></nobr>.</p>

<p>Дальше будут рассказываться довольно странные вещи, так что потерпите и постарайтесь дочитать.</p>

<p>Моя Первая Структура<sup><small>TM</small></sup>—<a name="indexId434909-67"></a><nobr><tt class="type">struct
addrinfo</tt></nobr>.  Эта структура появилась позднее, она используется для того, чтобы сохранить адрес сокета для последующих использований. Также она используется при поиске имени хоста и поиске имени сервиса (host/service name lookup). Станет гораздо более понятно, когда мы дойдём до реального использования в коде, а пока - просто знай что это одна из первых вещей, которые пригодятся тебе при создании соединения.</p>

<pre class="code">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for "any"
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};</pre>


<p>Ты заполняешь эту структуру, а после вызываешь <a name="indexId434909-68"></a><b><tt class="func">getaddrinfo()</tt></b>. Она возвращает указатель на новый линкованный список этих структур, заполненный всем, чем тебе нужно.</p>

<p>Ты можешь потребовать использовать IPv4 или IPv6, изменяя поле <i><tt class="var">ai_family</tt></i> или оставить его как <tt class="const">AF_UNSPEC</tt>, чтобы версия протокола была выбрана по умолчанию. Это круто, потому что тогда твой код может быть написан без привязки к версии IP.</p>

<p>Обрати внимание на связный список в конце структуры: <i><tt class="var">ai_next</tt></i> указывает на следующий элемент - могут быть возвращены несколько результатов, и ты можешь выбирать из них. Я обычнор использую первый результат, который будет работать, но возможно в твоей бизнес-логике будет сделано по-другому; Я не могу знать всего, парень!</p>

<p>Обрати внимание, что поле <i><tt class="var">ai_addr</tt></i> в структуре <nobr><tt class="type">struct
addrinfo</tt></nobr> - это указатель на структуру <a name="indexId434909-69"></a><nobr><tt class="type">struct sockaddr</tt></nobr>. Это место, с которого мы начнём вникать в мельчайшие детали того, что содержится в структуре IP-адреса.</p>

<p>Как правило, тебе не нужно самому заполнять эти структуры; довольно часто, вызов <b><tt class="func">getaddrinfo()</tt></b>, заполняющий твою <nobr><tt class="type">struct addrinfo</tt></nobr> - это то, что тебе нужно. Тем не менее, тебе <i>будет нужно</i> вникнуть в детали этих <nobr><tt class="type">struct</tt></nobr>ов, чтобы уметь доставать оттуда необходимые данные, поэтому я и рассказываю о них.</p>

<p>(Также, весь код, написанный до появления <nobr><tt class="type">struct addrinfo</tt></nobr> запаковывал все эти данные вручную, поэтому иногда в жизни можно увидеть кучу кода, связанного с IPv4, который делает ровно то же самое. Например, в прошлый версиях этого руководства и т.п.)</p>

<p>Некоторые <nobr><tt class="type">struct</tt></nobr>ы работают с IPv4, некоторые - с IPv6, а некоторые - с обоими версиями. Я укажу, что есть что.</p>

<p>Так или иначе, <nobr><tt class="type">struct sockaddr</tt></nobr> содержит адрес сокета, который может быть заполнен для нескольких типов сокетов.</p>

<pre class="code">struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
}; 
</pre>


<p><i><tt class="var">sa_family</tt></i> может быть тучей различных вещей, но в этом документе она будет либо <a name="indexId434909-70"></a><tt class="const">AF_INET</tt> (IPv4), либо <a name="indexId434909-71"></a><tt class="const">AF_INET6</tt> (IPv6).  <i><tt class="var">sa_data</tt></i> содержит адрес получателя и номер порта для сокета. Это довольно громоздко, поскольку ты не хочешь нудно запаковывать адрес в <i><tt class="var">sa_data</tt></i> вручную.</p>

<p>Для того, чтобы работать с <nobr><tt class="type">struct sockaddr</tt></nobr>, программисты создали схожую структуру: <a name="indexId434909-72"></a><nobr><tt class="type">struct
sockaddr_in</tt></nobr> ("in" значит "Internet") для использования с IPv4.</p>

<p>И ещё одно небольшое<i>важное</i> замечание: указатель на <nobr><tt class="type">struct sockaddr_in</tt></nobr> может быть приведён к ауказателю на <nobr><tt class="type">struct sockaddr</tt></nobr> и наоборот. Поэтому, несмотря на то, что <b><tt class="func">connect()</tt></b> принимает <nobr><tt class="type">struct sockaddr*</tt></nobr>, ты можешь использовать <nobr><tt class="type">struct sockaddr_in</tt></nobr> и кастить его в последний момент перед передачей!</p>

<pre class="code">// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
</pre>


<p>Эта структура позволяет легко обращаться к элементам адреса сокета. Обрати внимание, что <i><tt class="var">sin_zero</tt></i> (добавленный, чтобы размер структуры совпадал с размером <nobr><tt class="type">struct sockaddr</tt></nobr>) должен быть заполнен нулями с помощью функции <b><tt class="func">memset()</tt></b>.  Также, учти, что <i><tt class="var">sin_family</tt></i> соответствует <i><tt class="var">sa_family</tt></i>
в <nobr><tt class="type">struct sockaddr</tt></nobr> и должен быть установлен как "<tt class="const">AF_INET</tt>".  Наконец, <i><tt class="var">sin_port</tt></i> должен быть записан в <a name="indexId434909-73"></a><i>Сетевом Порядке Байт</i> (используя <a name="indexId434909-74"></a><b><tt class="func">htons()</tt></b>!)</p>

<p>Давай компнём ещё глубже! Обрати внимание, что поле <i><tt class="var">sin_addr</tt></i> field имеет тип <nobr><tt class="type">struct in_addr</tt></nobr>. Это что ещё за штука? Ну, не хочу слишком пугать тебя, но это один из самых страшных <i><tt class="var">union</tt></i>ов всех времён:</p>

<pre class="code">// (IPv4 only--see struct in6_addr for IPv6)

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};</pre>


<p>Вот так!  Вообще говоря, <i>раньше</i> это был <i><tt class="var">union</tt></i>, но те дни прошли. Скатертью дорожка. Поэтому, если ты объявил, что <i><tt class="var">ina</tt></i> имеет тип <nobr><tt class="type">struct sockaddr_in</tt></nobr>, то <i><tt class="var">ina.sin_addr.s_addr</tt></i> указывает на 4-байтовый IP-адрес (в Сетевом Порядке Байт). Заметь, что даже если твоя система использует богомерзкий <i><tt class="var">union</tt></i> для <nobr><tt class="type">struct in_addr</tt></nobr>, ты всё ещё можешь обращаться к 4-байтному IP-адресу точно так же, как я указал выше (это связано с <tt class="tt">#define</tt>ами.)</p>

<p>А что насчёт <a name="indexId434909-75"></a>IPv6?  Точно таким же образом, для него существует <nobr><tt class="type">struct</tt></nobr>:</p>

<pre class="code">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};</pre>


<p>Обрати внимание, что IPv6 имеет IPv6-адрес и номер порта, так же как IPv4 имеет IPv4-адрес и номер порта.</p>

<p>Также, заметь, что я не рассказываю о полях, представляющих IPv6 flow information или Scope ID... это всего лишь руководство для начинающих.
<tt>:-)</tt></p>

<p>Последней, но не по значению, будет другая простая структура, <nobr><tt class="type">struct sockaddr_storage</tt></nobr>, которая была создана для того, чтобы иметь возможность хранить как IPv4, так и IPv6- структуры.  (Это нужно потому, что иногда ты заранее не знаешь, собирается функция заполнить твою <nobr><tt class="type">struct sockaddr</tt></nobr> IPv4 или IPv6-адресом. Поэтому ты просто передаёшь эту универсальную структуру, очень похожую на <nobr><tt class="type">struct
sockaddr</tt></nobr>, только немного больше, а затем кастишь её к типу, который тебе нужен:</p>

<pre class="code">struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};</pre>


<p>Что действительно важно, так это то, что ты можешь достать тип адреса из <i><tt class="var">ss_family</tt></i>, а дальше проверить, что это <tt class="const">AF_INET</tt> или <tt class="const">AF_INET6</tt> (для IPv4 и
IPv6 соответственно). Затем, ты можешь скастить её к типу <nobr><tt class="type">struct sockaddr_in</tt></nobr> или <nobr><tt class="type">struct sockaddr_in6</tt></nobr>, если тебе это нужно.</p>

 






<h3 class="sect2title">3.4. <a name="ipaddrs2">IP-адреса, Часть Вторая</a></h3>


<p>К счастью для тебя, существует несколько функций, позволяющих тебе управлять <a name="indexId434909-76"></a>IP-адресами. Нет необходимости писать их самостоятельно и хранить всё в <nobr><tt class="type">long</tt></nobr>ах, работая оператором битового сдвига <tt class="tt">&lt;&lt;</tt>.</p>

<p>Во-первых, допустим у тебя есть <nobr><tt class="type">struct sockaddr_in ina</tt></nobr>, и есть IP-адрес "<tt class="tt">10.12.110.57</tt>" или
"<tt class="tt">2001:db8:63b3:1::3490</tt>", который ты хочешь в ней сохранить. Функция, которую тебе нужна называется <a name="indexId434909-77"></a>
<b><tt class="func">inet_pton()</tt></b>. Она конвертирует IP-адрем в числах-и-точках либо в <nobr><tt class="type">struct in_addr</tt></nobr>, либо в <nobr><tt class="type">struct in6_addr</tt></nobr> в зависимости от того, используешь ты <tt class="const">AF_INET</tt>
или <tt class="const">AF_INET6</tt>.  ("pton" означает "presentation to
network"—можешь называть её "printable to network", если тебе так легче запомнить.) Такая конверсия может быть произведена следующим образом:</p>

<pre class="code">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, "192.0.2.1", &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &amp;(sa6.sin6_addr)); // IPv6</pre>


<p>(Небольшое замечание: раньше это делали, используя функцию <a name="indexId434909-78"></a><b><tt class="func">inet_addr()</tt></b> или другую, <a name="indexId434909-79"></a><b><tt class="func">inet_aton()</tt></b>; сейчас обе эти функции устарели и не работают с IPv6.)</p>

<p>На данный момент, кусок кода выше не слишком надёжен, потому что в нём нет проверки ошибок. Смотри, <b><tt class="func">inet_pton()</tt></b> возвращает <tt class="const">-1</tt> в случае ошибки, или 0, если не может распарсить адрес. Поэтому, не забудь проверить, что возвращённыйй результат больше 0 перед тем, как использовать полученный <nobr><tt class="type">struct</tt></nobr>!</p>

<p>Отлично, теперь ты можешь конвертировать строковое представление IP-адреса в его битовое представление. А что если тебе нужно наоборот? Что если у тебя есть <nobr><tt class="type">struct in_addr</tt></nobr> и ты хочешь получить человекочитаемое представление (числа и точки)?   (Или <nobr><tt class="type">struct in6_addr</tt></nobr> из которой ты хочешь получить шестнадцатеричные числа и точки.) В этом случае, тебе нужно использовать функцию <a name="indexId434909-80"></a><b><tt class="func">inet_ntop()</tt></b> ("ntop" означает
"network to presentation"—называй её "network to printable", если тебе так проще запомнить), вот так:</p>

<pre class="code">// IPv4:

char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf("The IPv4 address is: %s\n", ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf("The address is: %s\n", ip6);</pre>


<p>Когда тебе понадобится вызвать её, ты передашь тип адреса (IPv4 or IPv6), непосредственно адрес, указатеь на строку, в которой необходимо сохранить результат и максимальную длину этой строки.  (Две константы хранят правильные размеры строк, необходимых для хранения строкового представления IPv4 или IPv6-адреса: <tt class="const">INET_ADDRSTRLEN</tt> и <tt class="const">INET6_ADDRSTRLEN</tt>.)</p>

<p>(Ещё одно небольшое замечание, просто чтобы упомянуть старый способ делать всё это: исторически, функция, выполняющая конвертацию, называлась <a name="indexId434909-81"></a><b><tt class="func">inet_ntoa()</tt></b>. На данный момент она устаревшая и не работает с IPv6.)</p>

<p>Наконец, эти функции работают только с численными IP-адресами: они не будут обращаться к DNS-серверу если им передать, скажем "www.example.com". Далее я расскажу тебе, что ты можешь использовать для этих целей <b><tt class="func">getaddrinfo()</tt></b>.</p>



<h4 class="sect3title">3.4.1. <a name="privnet">Приватные (Или Отключённые) Сети</a></h4>


<p><a name="indexId434909-82"></a>Очень многие сети имеют <a name="indexId434909-83"></a>файрволл, который прячет их от остального мира. И часто в таких случаях этот файрволл транслирует "внутренние" IP-адреса во "внешние" (те, к которым может обратиться кто угодно в мире) IP-адреса, используя процесс, называемый <i>Network
Address Translation</i>, или <a name="indexId434909-84"></a>NAT.</p>

<p>Ты уже начал нервничать?  "Куда он ведёт со всей этой странной ерундой?"</p>

<p>Ну, расслабься и купи себе безалкогольный (или алкогольный) напиток, потому что будучи начинающим, тебе даже не нужно беспокоиться о NAT, поскольку он работает без твоего участия. Но я хотел поговорить о сети за файрволлом, на случай если ты начнёшь удивляться IP-адресам, которые будешь получать.</p>

<p>Допустим, у меня дома установлен файрволл. У меня есть два статических IPv4-адресов, зарезервированных для меня провайдером, но в сети у меня 7 компьютеров. Как это вообще возможно? Ведь два компьютера не могут делать один IP-адрес, иначе данные не будут знать, куда им идти!</p>

<p>Ответ таков: они и не делят один IP-адрес. Они находятся в приватной сети с 24 миллионами доступных IP-адресов. Эта сеть моя и только моя. Вот как это сделано:</p>

<p>Если я логинюсь в удалённый компьютер, он говорит мне что я вошёл под адресом 192.0.2.33 - публичным IP-адресом, данным мне провайдером. Но если я спрошу IP-адрес у локального компьютера, он выдаёт мне 10.0.0.5. Кто же меняет IP-адреса? Правильно, файрволл! Он выполняет  NAT!</p>

<p>10.<i>x</i>.<i>x</i>.<i>x</i> - одна из немногих зарезервированных сетей, которые могут быть использованы только с полностью отключёнными сетями, либо с сетями за файрволлом. Детали того, какие адреса приватных сетей доступны тебе, можно найти в <a href="http://tools.ietf.org/html/rfc1918" target="_blank">RFC 1918</a>, но обычно используют <a name="indexId434909-85"></a>10.<i>x</i>.<i>x</i>.<i>x</i> и <a name="indexId434909-86"></a>192.168.<i>x</i>.<i>x</i>, где <i>x</i>
варьируется между 0 и 255. Менее известна сеть 172.<i>y</i>.<i>x</i>.<i>x</i>, где <i>y</i> варьируется между 16 и 31.</p>

<p>Сети, спрятанные за файрволлом, выполняющим NAT, не <i>обязаны</i> иметь один из вышеприведённых адресов, но обычно они имеют.</p>

<p>(Забавный факт! Мой внешний IP-адрес на самом деле не 192.0.2.33. Сеть 192.0.2.<i>x</i> зарезервирована для тех простофиль, которые поверили, что я буду использовать "реальные" IP-адреса в документации навроде этого руководства. Вот так!)</p>

<p><a name="indexId434909-87"></a>Кстати, в IPv6 тоже есть приватные сети. Они начинаются с <tt class="tt">fd<i>xx</i>:</tt> (или, возможно, в будущем <tt class="tt">fc<i>XX</i>:</tt>), согласно <a href="http://tools.ietf.org/html/rfc4193" target="_blank">RFC 4193</a>. Тем не менее, NAT и IPv6 никак не связаны (если конечно ты не делаешь IPv6-IPv4 шлюз, что выходит за рамки данной статьи)—в теории, у тебя в распоряжении столько адресов, что тебе больше не нужно использовать NAT. Но если ты хочешь выделить адреса для себя, в сети, которая не будет доступна снаружи, то так и надо делать.</p>

 

 

<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="theory.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="ip4to6.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>

</body>
</html>
