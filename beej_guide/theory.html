<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Что такое сокет?</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="intro.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="ipstructsdata.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>


<h2 class="sect1title">2. <a name="theory">Что такое сокет?</a></h2><hr class="mainsecthr"/>


<p>Ты постоянно слышишь разговоры о сокетах, и возможно, хочешь узнать, чем они являются на самом деле? <a name="indexId434909-21"></a>
 Так вот, сокеты это способ общения между программами, используя стандартные Unix`овые файловые дескрипторы<a name="indexId434909-22"></a>.</p>

<p>Чего?</p>

<p>Ок, возможно ты слышали от своего друга-хакера, "Иисусе, всё в Unix является <i>файлом</i>!" Когда говорят такое, имеется в виду факт, что 
когда Unix программы делают что-то с вводом/выводом, они делают это с помощью чтения из и записи в файловый дескриптор. 
Файловый дескриптор - это просто целое число, привязанное к открытому файлу. Но (и в этом вся соль), файлом может быть открытое сетевое соединение, 
FIFO, пайп, терминал, реальный файл на диске или что-то иное. Всё в Unix <i>является</i> файлом! Поэтому, не хочешь - не верь, а если тебе захочется 
наладить связь с другой программой по интернету, ты будешь делать это через файловый дескриптор.</p>

<p>"И где же мне взять такой файловый дескриптор для общения по сети, Мистер Умные Штанишки?" - возможно, последнее, о чём ты сейчас думаешь, но я всё же дам ответ на этот вопрос: ты можешь вызвать системный вызов <a name="indexId434909-23"></a><b><tt class="func">socket()</tt></b>. 
Он возвращает <a name="indexId434909-24"></a> дескриптор сокета, и ты можешь наладить коммуникацию через него, используя специальные вызовы: 
 <a name="indexId434909-25"></a><b><tt class="func">send()</tt></b>
и <a name="indexId434909-26"></a><b><tt class="func">recv()</tt></b> (<b class="com"><a href="sendman.html">man
send</a></b>, <b class="com"><a href="recvman.html">man recv</a></b>).</p>

<p>"Погоди-ка!", возможно восклицаешь ты сейчас.  "Если это файловый дескриптор, почему во имя Нептуна я не могу использовать обычные  
<a name="indexId434909-27"></a><b><tt class="func">read()</tt></b> and <a name="indexId434909-28"></a><b><tt class="func">write()</tt></b>, чтобы общаться через сокет?"  Короткий ответ: "Ты можешь!", более длинный: "Ты можешь, но  <a name="indexId434909-29"></a><b><tt class="func">send()</tt></b> и <a name="indexId434909-30"></a><b><tt class="func">recv()</tt></b> дают тебе гораздо больший контроль над передачей данных."</p>

<p>Что дальше?  Как насчёт этого: есть много типов сокетов. Существуют <a name="indexId434909-31"></a>интернет адреса DARPA (интернет-сокеты), названия путей на локальной машине (Unix - сокеты), CCITT X.25
адреса (X.25 сокеты, о которых ты можешь спокойно забыть), и, возможно, куча других, в зависимости от варианта Unix, который ты исользуешь. 
Этот документ рассматривает только первые: интернет-сокеты (Internet Sockets).</p>







<h3 class="sect2title">2.1. <a name="twotypes">Два типа интернет-сокетов</a></h3>


<p>Что это?  <a name="indexId434909-32"></a>То есть, есть два типа интернет-сокетов? Да. Вообще-то нет. Я соврал. Их больше, но я не хочу пугать тебя. В этой статье я хочу рассказать только о двух типах. Не считая этого предложения, в котором я хочу сказать, что "<a name="indexId434909-33"></a><a name="indexId434909-34"></a>Raw Sockets" - также очень мощный инструмент и тебе следует разобраться с ними.</p>

<p>Вот так, поехали. Что это за два типа? Один - это "<a name="indexId434909-35"></a>потоковые сокеты (Stream Sockets)"; другой - это "<a name="indexId434909-36"></a>датаграм-сокеты (Datagram Sockets)". Далее два эти понятия будут упоминаться как "<tt class="const">SOCK_STREAM</tt>" и
"<tt class="const">SOCK_DGRAM</tt>", соответственно. Датаграм-сокеты иногда называются "сокетами без соединения". (Хотя, иногда они могут <a name="indexId434909-37"></a><b><tt class="func">connect()</tt></b>'иться, если тебе действительно это нужно. Смотри <b><tt class="func"><a href="syscalls.html#connect">connect()</a></tt></b>, ниже.)</p>

<p>Потоковые сокеты - это надёжные двухсторонние потоки передачи данных. Если ты выведешь два слова в сокет в порядке  "1, 2", в этом порядке они и придут получателю. Также, они работают без ошибок. Я настолько уверен, что они работают без ошибок, что я засуну пальцы в уши и буду кричать <i>ла ла ла ла</i>, если кто-то другой попробует высказать обратное утверждение.</p>

<p>Где используются <a name="indexId434909-38"></a>потоковые сокеты? Ну, возможно ты слышали о приложении <a name="indexId434909-39"></a><b class="com">telnet</b>, не так ли? Оно использует потоковые сокеты. Все символы, которые ты ввел должны быть доставлены в том же порядке, в котором они были напечатаны, так ведь? Кроме того, браузеры используют протокол <a name="indexId434909-40"></a>HTTP, который использует потоковые сокеты для приёма страниц. Буквально, если ты подключишься по telnet к вебсайту через порт 80, введёшь "<tt class="tt">GET / HTTP/1.0</tt>" и нажмёшь Enter дважды, он вернёт тебе HTML!</p>

<p>Как потоковые сокеты добиваются такого высокого качества передачи данных? Они используют протокол, называемый "The Transmission Control
Protocol", также известный как <a name="indexId434909-41"></a>"TCP" (см. <a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC 793</a> если хочешь увидеть максимально детализированную информацию о TCP.) TCP обеспечивает то, что ваши данные приходят последовательно и не без ошибок. Возможно, ты ранее слышал о TCP в контесте "TCP/IP", где <a name="indexId434909-42"></a> "IP" означает "Internet Protocol" (см. <a href="http://tools.ietf.org/html/rfc791" target="_blank">RFC 791</a>.)  IP в основном занимается маршрутизацией и не несёт ответсвенность за состояние данных.</p>

<p>Супер. <a name="indexId434909-43"></a>А что такое датаграм-сокеты? Почему они называются сокетами без соединения? На что это влияет? Почему они ненадёжные? Вот несколько фактов: если ты посылаешь датаграм, он может прийти. Он может прийти не в том порядке. Но если он придёт, данные внутри пакета будут без ошибок.</p>

<p>Датаграм - сокеты также используют IP для маршрутизации, но они не используют TCP: они используют "User Datagram Protocol", или <a name="indexId434909-44"></a>"UDP" (см.
<a href="http://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a>.)</p>

<p>Почему они называются сокетами без соединения? В основном, потому что тебе не нужно поддерживать открытое соединение при работе с ними, как ты делаете это с потоковыми сокетами. Ты просто создаёшь пакет, шлёпаешь на него заголовок IP c местом назначения и отправляешь его. Не нужно никаких соединений. Этот протокол используется обычно когда TCP не доступен, или когда ситуация, что парочка потерянных пакетов тут и там - это не конец света. Примеры использующих приложений: <b class="com">tftp</b> (trivial file transfer protocol, младший брат FTP), <b class="com">dhcpcd</b> (DHCP -клиент), многопользовательские игры, потоковое аудио, видео-коференции и прочая.</p>

<p>"Погоди-ка!  <b class="com">tftp</b> и <b class="com">dhcpcd</b> используются для передачи исполняемых файлов от одного компьютера к другому! Данные не должны быть потеряны, если ты ожидаешь, что файл запустится после приёма! Что за чёрная магия тут происходит?"</p>

<p>Дорогой друг, <b class="com">tftp</b> и похожие программы используют свой собственный протокол поверх UDP. Например, документация протокола tftp гласит, что для каждого полечученного пакета, получатель должен отправить назад пакет, который означает "Я получил!" ("ACK" - пакет.) Если отправитель не может дождаться ответа в течение, скажем, пяти секунд он будет повторять отправку пакета, пока наконец не получит ACK. 
Такая процедура проверки очень важна при реализации надёжных приложений, использующих <tt class="const">SOCK_DGRAM</tt>.</p>

<p>В случае ненадёжного приложения, например игр, аудио, видео, ты можешь просто проигнорировать потерянный покет или, возможно, попытаться по-умному их компенсировать. (Игроки в Quake, возможно, знают проявление этого эффекта под названием <i>accursed lag</i>.  Слово "accursed" в этом случае имеет весьма грубое значение.)</p>

<p>Зачем использовать ненадёжный протокол? Две причины: скорость и скорость. Гораздо быстрее отправить пакет и забыть, чем отслеживать, прибыл ли он на место, в том ли порядке и всё такое. Если ты посылаешь сообщения, TCP отлично подходит, но если ты отправляешь 40 изменений позиции в секунду игрокам по всему миру, скорее всего, не слишком важно, если один или два потеряются - и тогда UDP отлично подходит.</p>









<h3 class="sect2title">2.2. <a name="lowlevel">Низкоуровневая ерунда и Теория Сетей</a></h3>


<p>Посколько я только что упомянул слои протоколов, самое время поговорить о том, как сети на самом деле работают, а так же показать несколько примеров того, как строятся <a name="indexId434909-45"></a><tt class="const">SOCK_DGRAM</tt>-пакеты. На практике, ты можешь пропустить этот раздел. Тем не менее, это весьма полезная информация.</p>

<a name="figure1" /><center>
<div><img src="dataencap-120-4.736.png" alt="[Encapsulated Protocols Diagram]"/></div>

<p><b>Инкапсуляция Данных.</b></p>
</center>


<p>Эй, детишки, пришло время узнать о <a name="indexId434909-46"></a><i><a href="theory.html#figure1">Инкапсуляции Данных</a></i>! Это очень, очень важно. Это настолько важно, что возможно, ты узнаешь об этом если послушаешь курс сетей здесь, в Калифорнийском университете <tt>;-)</tt>.  В первом приближении, смысл такой: пакет создаётся, пакет оборачивается ("инкапсулируется") <a name="indexId434909-47"></a>заголовком (и иногда <a name="indexId434909-48"></a>окончанием) первым протоколом (например, <a name="indexId434909-49"></a>TFTP), затем, всё получившееся (включая заголовок TFTP) оборачивается снова следующим протоколом, скажем, <a name="indexId434909-50"></a>UDP, затем следующим (<a name="indexId434909-51"></a>IP), и наконец последним протоколом на физическом уровне (скажем, <a name="indexId434909-52"></a>Ethernet).</p>

<p>Когда другой компьютер получает пакет, железо снимает заголовок Ethernet, ядро снимает заголовки IP и UDP, TFTP снимает заголовок TFTP и наконец, получает данные.</p>

<p>Наконец, я могу рассказать о Now I can finally talk about the ползующейся дурной славой <a name="indexId434909-53"></a><i>Сетевой Модели OSI</i> (aka "ISO/OSI"). Эта Сетевая Модель описывает функциональность сети, которая имеет много преимуществ по сравнению с другими моделями. Например, ты можешь писать программы, работающие с сокетами точно также, не заботясь о том, как на самом деле данные доставляются физически (последовательно, Ethernet, AUI, что угодно), потому что программы на более низком уровне делают это за тебя. Реальная работа с железом и топологией сети отделена от программиста, рабтающего с сокетами.</p>

<p>На этом хватит присказок, сейчас я опишу тебе уровни полного стека этой модели. Запомни это, пригодится на экзамене по сетям:</p>

<ul>

<li>Прикладной</li>

<li>Уровень представления</li>

<li>Сеансовый</li>

<li>Транспортный</li>

<li>Сетевой</li>

<li>Канальный</li>

<li>Физический</li>

</ul>


<p>Физический уровень - это железо (последовательное соединение, Ethernet, и т.д.). Прикладной уровень настолько далёк от физического, насколько ты можешь сбее это представить - это место, где пользователи непосредственно работают с сетью.</p>

<p>В таком виде эта модель настолько всеобемлюща, что ты можешь использовать её как руководство по починке своего автомобиля. Сетевая модель, связанная с Unix, выглядит так:</p>

<ul>

<li>Прикладной уровень (Application Layer) (<i>telnet, ftp, etc.</i>)</li>

<li>Уровень компьютер-компьютер (Host-to-Host Transport Layer) (<i>TCP, UDP</i>)</li>

<li>Интернет-уровень(Internet Layer) (<i>IP and routing</i>)</li>

<li>Уровень доступа к сети (Network Access Layer) (<i>Ethernet, wi-fi, or whatever</i>)</li>

</ul>


<p>Теперь ты, возможно, видишь, как эти уровни соответствуют порядку инкапсуляции исходных данных.</p>

<p>Видишь, как много работы нужно, чтобы просто собрать пакет? Иисусе! И тебе ведь придётся дописывать все эти заголовки, используя "<b class="com">cat</b>"! Шучу. Всё что тебе нужно сделать, если ты используешь потоковые сокеты, это послать (<a name="indexId434909-54"></a><b><tt class="func">send()</tt></b>) данные. Всё, что тебе нужно сделать, если ты используешь датаграм-сокеты это обернуть пакет так, как ты хочешь и послать(<a name="indexId434909-55"></a><b><tt class="func">sendto()</tt></b>) его. Ядро соберёт транспортный и интернет-уровень для тебя, а железка займётся уровнем доступа к сети. Ах, эти современные технологии.</p>

<p>На этом мы закончим краткое содержание теории сетей. О, точно, я забыл сказать тебе кое-что о маршрутизации: ничего! Именно так, я не собираюсь рассказывать об этом. Маршрутизатор вытаскивает IP-заголовок, сверяется с таблицей маршрутизации, <a name="indexId434909-56"></a>бла бла бла. Почитай <a href="http://tools.ietf.org/html/rfc791" target="_blank">IP RFC</a>, если тебе действительно есть до этого дела. Если ты ничего не будешь знать об этом, ничего с тобой от этого не случится.</p>



<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="intro.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="ipstructsdata.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>

</body>
</html>
