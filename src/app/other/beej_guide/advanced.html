<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Slightly Advanced Techniques</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="clientserver.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="faq.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>


<h2 class="sect1title">7. <a name="advanced">Чуть более продвинутые методы</a></h2><hr class="mainsecthr"/>


<p>Они не являются <i>сильно</i> продвинутыми, но, тем не менее, они выходят за границы базовых вещей, о которых мы говорили ранее. 
По большому счёту, если ты дочитал до этого места, ты можешь считать себя вполне освоившимся в основах сетевого программирования в Unix! Мои поздравления!</p>

<p>Поэтому сейчас мы вступим в совершенно новый мир некоторых более хитрых вещей, которые тебе стоит знать о сокетах. Вперёд!</p>







<h3 class="sect2title">7.1. <a name="blocking">Блокировка</a></h3>


<p><a name="indexId434909-142"></a>Блокировка. Ты уже слышал о ней - но что это такое? В двух словах, "блокироваться" - это технический жаргон для "засыпать". Возможно, ты обратил внимание, что когда ты запускаешь <b class="com">listener</b>, он просто сидит и ждёт, пока не придёт пакет. Это происходит потому, что он вызывает 
<b><tt class="func">recvfrom()</tt></b>, и если данных нет, то вызов 
<b><tt class="func">recvfrom()</tt></b> "блокируется" (именно, засыпает) до тех пор, пока данные не придут.</p>

<p>Многие функции блокируются. <b><tt class="func">accept()</tt></b> блокируется.
Обе функции <b><tt class="func">recv()</tt></b> блокируются. Они делают это потому что могут так делать. Когда ты первый раз создаёшь дескриптор сокета с помощью <b><tt class="func">socket()</tt></b>, ядро по умолчанию делает его блокирующим.
 <a name="indexId434909-143"></a>Если ты не хочешь, чтобы сокет блокировался, тебе необходимо вызвать <a name="indexId434909-144"></a><b><tt class="func">fcntl()</tt></b>:</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
. 
</pre>


<p>Делая сокет неблокирующим, ты можешь эффективно "опрашивать" сокет на наличие информации. Если ты попытаешься прочитать из неблокирующего 
сокета в тот момент, когда там нет данных, вызов не заблокируется, а вернёт <tt class="const">-1</tt> и <i><tt class="var">errno</tt></i> присвоится значение <a name="indexId434909-145"></a><tt class="const">EWOULDBLOCK</tt>.</p>

<p>По большому счёту, опрашивать сокеты таким образом - это плохая идея. Если ты заставишь свою программу в бесконечном цикле спрашивать данные у сокета, она будет отнимать очень много процессорного времени, что весьма плохо. Более элегантное решение для проверки сокета на наличие данных описано в следующем разделе о функции <a name="indexId434909-146"></a><b><tt class="func">select()</tt></b>.</p>









<h3 class="sect2title">7.2. <a name="select"><b><tt class="titlefunc">select()</tt></b>—Синхронное мультиплексирование I/O</a></h3>


<p><a name="indexId434909-147"></a>Эта функция выглядит довольно странной, но она очень полезна. Представь ситуацию: 
ты сервер, и ты хочешь слушать входящие соединения одновременно с чтением из существующих.</p>

<p>Нет проблем, скажешь ты, всего лишь <b><tt class="func">accept()</tt></b> и парочка вызовов <b><tt class="func">recv()</tt></b>. 
Не так быстро, парень! А что если ты заблокируешься на вызове <b><tt class="func">accept()</tt></b>? Как ты собираешься получать данные в это же время? "Использовать неблокирующие сокеты!" Никогда! Ты же не хочешь быть CPU-обжорой. Что тогда?</p>

<p><b><tt class="func">select()</tt></b> даёт тебе возможность просматривать несколько сокетов одновременно. Он говорит тебе, какой из 
сокетов готов для чтения, какой - для записи, а какой броил исключение, если тебе нужно это знать.</p>

<p>В современном мире, <b><tt class="func">select()</tt></b>, хоть и весьма переносимая функция, является одним из самых медленных 
методов для просмотра информации о состоянии сокетов. Возможная альтернатива - <a href="http://www.monkey.org/~provos/libevent/" target="_blank">libevent</a>, или что-то подобное, что-то, что прячет все платформозависимые вызовы внутри.</p>

<p>А теперь, без дальнейших церемоний, сигнатура вызова
<b><tt class="func">select()</tt></b>:</p>

<pre class="code">#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout); 
</pre>


<p>Эта функция мониторит "множества" файловых дескрипторов; в частности,
<i><tt class="var">readfds</tt></i>, <i><tt class="var">writefds</tt></i>, и
<i><tt class="var">exceptfds</tt></i>. Если хочешь уметь видеть записанное в стандартны ввод и
какой-то дескриптор сокета 
<i><tt class="var">sockfd</tt></i>, просто добавь файловые дескрипторы
<tt class="const">0</tt> и <i><tt class="var">sockfd</tt></i> в множество
<i><tt class="var">readfds</tt></i>.  Параметра
<i><tt class="var">numfds</tt></i> должен иметь значение "максимальный номер файлового дескриптора плюс 1". 
В этом примере, он должен иметь значение <i><tt class="var">sockfd+1</tt></i>, поскольку он уж точно больше, чем 
стандартный ввод (<tt class="const">0</tt>).</p>

<p>Когда управление после вызова <b><tt class="func">select()</tt></b> возвращается,
<i><tt class="var">readfds</tt></i> будет модифицировано так, чтобы показать, какой из файловых дескрипторов готов для 
чтения из него. Ты можешь проверить это используя функцию <b><tt class="func">FD_ISSET()</tt></b>, описанное ниже.</p>

<p>Перед тем как идти дальше, я хочу поговорить о том, как управлять этими множествами. Каждое из множеств имеет тип <nobr><tt class="type">fd_set</tt></nobr>. Эти функции могут управлять этим типом: </p>

<p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="50%%"><p><a name="indexId434909-148"></a><b><tt class="func">FD_SET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left" width="48%%"><p>Добавить <i><tt class="var">fd</tt></i> в <i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-149"></a><b><tt class="func">FD_CLR(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Удалить <i><tt class="var">fd</tt></i> из <i><tt class="var">set</tt></i>а.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-150"></a><b><tt class="func">FD_ISSET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Вернуть true если <i><tt class="var">fd</tt></i> содержится в
<i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-151"></a><b><tt class="func">FD_ZERO(fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Удалить все записи из <i><tt class="var">set</tt></i>.</p></td>
</tr>

</table></center>
</p>

<p>Наконец, что это за странная <a name="indexId434909-152"></a>
<nobr><tt class="type">struct timeval</tt></nobr>?
Ну, иногда ты не хочешь ждать вечно, пока кто-нибудь не пришлёт тебе данные. Возможно, каждые 96 секунд 
ты хочешь вывести "Всё ещё работает..." в консоль, даже если ничего не произошло. Эта временная структура позволит тебе определить 
таймаут. Если время вышло и <b><tt class="func">select()</tt></b> до сих пор не нашёл файловых дескрипторов, которые готовы к работе, функция
завершится, чтобы ты мог продолжить обработку.</p>

<p>Структура <nobr><tt class="type">struct timeval</tt></nobr> имеет поля:</p>

<pre class="code">struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
}; 
</pre>


<p>Просто присвой в <i><tt class="var">tv_sec</tt></i> сколько ты готов ждать в секундах, и в <i><tt class="var">tv_usec</tt></i> - остаток в микросекундах. Да, это <i>микро</i>секунды, а не миллисекунды. В миллисекунде 1,000 микросекунд и в секунде 1,000 миллисекунд. 
Таки образом, в секунде 1,000,000 микросекунд. Почему же поле называется "usec"?  Предполагается, что "u" похожа на греческую букву &#x03BC; (Мю), что означает "микро". Также, когда функция завершает работу, <i><tt class="var">timeout</tt></i> <i>может</i> быть обновлён, чтобы 
показать, сколько времени ещё осталось. Это зависит от того, какой именно Unix ты запускаешь.</p>

<p>Вау! У нас есть микросекундный таймер! Ну, особо надеяться на него не стоит. Тебе всё равно придётся потерпеть несколько стандартных системных задержек, вне зависимости от того, насколько малой ты сделал свою <nobr><tt class="type">struct
timeval</tt></nobr>.</p>

<p>Ещё один интересный факт: Если ты установил все поля 
<nobr><tt class="type">struct timeval</tt></nobr> в <tt class="const">0</tt>, то 
<b><tt class="func">select()</tt></b> завершит работу немедленно, как только опросит все файловые дескрипторы в полученных множествах.
 А если присвоить в <i><tt class="var">timeout</tt></i> NULL, то она не завершит свою работу, пока первый файловый дескриптор не будет 
 готов. Наконец, если тебя не интересует определённое множество, ты можешь передать вместо него NULL в <b><tt class="func">select()</tt></b>.</p>

<p><a href="http://beej.us/guide/bgnet/examples/select.c" target="_blank">Следующий блок кода</a> ожидает 2.5 секунды того, что что-то появится в стандартном вводе:</p>

<pre class="code">/*
** select.c -- a select() demo
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // file descriptor for standard input

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // don't care about writefds and exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf("A key was pressed!\n");
    else
        printf("Timed out.\n");

    return 0;
} 
</pre>


<p>Если ты используешь терминал, буферизующий строки, то в конце ты должен нажать Enter, иначе select() вернётся по таймауту.</p>

<p>Сейчас, ты можешь думать, что это отличный способ ожидать данные от датаграм-сокета, и ты прв: он <i>может</i> быть таким.
Некоторые Unixы могут использовать select таким образом, а некоторые - нет. Тебе следует посмотреть, что локальная man-страница говорит 
о таком способе использования select, если ты собираешься его использовать.</p>

<p>Некоторые Unixы обновляют время в <nobr><tt class="type">struct timeval</tt></nobr>, чтобы показать, сколько времени осталось до 
таймаута. Но другие не делают этого. Не стоит надеяться на такое поведение, если ты хочешь, чтобы твой код был переносимым. (используй 
<a name="indexId434909-153"></a><b><tt class="func">gettimeofday()</tt></b>, если хочешь измерить оставшееся время. Это довольно неприятно, 
но именно так это надо делать.)</p>

<p>Что произойдёт, если сокет в множестве читающих закроет соединение? В этом случае, <b><tt class="func">select()</tt></b> вернёт 
управление, пометив этот дескриптор как "готовый к чтению". Когда ты попытаешься вызвать 
<b><tt class="func">recv()</tt></b> на нём, <b><tt class="func">recv()</tt></b> вернёт <tt class="const">0</tt>. Таким образом ты узнаешь, что
 клиент закрыл соединение.</p>

<p>Ещё кое-что интересное о <b><tt class="func">select()</tt></b>: если у тебя есть сокет, который слушает (<a name="indexId434909-154"></a>
<a name="indexId434909-155"></a> <b><tt class="func">listen()</tt></b>), ты можешь проверить, есть ли в нём новые соединения, положив его файловый дескриптор в <i><tt class="var">readfds</tt></i> set.</p>

<p>И это, мои друзья, краткое описание всемогущего вызова <b><tt class="func">select()</tt></b>.</p>

<p>Но, по многочисленным просьбам, вот более глубокий пример. К сожалению, разница между обычным примером и этим весьма велика. 
Посмотри, а затем прочитай описание.</p>

<p><a href="http://beej.us/guide/bgnet/examples/selectserver.c" target="_blank">Эта программа</a> работает как простой многопользовательский 
чат-сервер. Запусти её в отдельном окне, затем свяжись с ней по <b class="com">telnet</b> ("<b class="com">telnet hostname
9034</b>") из нескольких других окон. Когда ты введёшь что-то в одной из сессий <b class="com">telnet</b>, это должно появиться во всех остальных.</p>

<pre class="code">/*
** selectserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define PORT "9034"   // port we're listening on

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    fd_set master;    // master file descriptor list
    fd_set read_fds;  // temp file descriptor list for select()
    int fdmax;        // maximum file descriptor number

    int listener;     // listening socket descriptor
    int newfd;        // newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // client address
    socklen_t addrlen;

    char buf[256];    // buffer for client data
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        // for setsockopt() SO_REUSEADDR, below
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&amp;master);    // clear the master and temp sets
    FD_ZERO(&amp;read_fds);

    // get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, "selectserver: %s\n", gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) { 
            continue;
        }
        
        // lose the pesky "address already in use" error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    // if we got here, it means we didn't get bound
    if (p == NULL) {
        fprintf(stderr, "selectserver: failed to bind\n");
        exit(2);
    }

    freeaddrinfo(ai); // all done with this

    // listen
    if (listen(listener, 10) == -1) {
        perror("listen");
        exit(3);
    }

    // add the listener to the master set
    FD_SET(listener, &amp;master);

    // keep track of the biggest file descriptor
    fdmax = listener; // so far, it's this one

    // main loop
    for(;;) {
        read_fds = master; // copy it
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(4);
        }

        // run through the existing connections looking for data to read
        for(i = 0; i &lt;= fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // we got one!!
                if (i == listener) {
                    // handle new connections
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror("accept");
                    } else {
                        FD_SET(newfd, &amp;master); // add to master set
                        if (newfd &gt; fdmax) {    // keep track of the max
                            fdmax = newfd;
                        }
                        printf("selectserver: new connection from %s on "
                            "socket %d\n",
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // handle data from a client
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {
                        // got error or connection closed by client
                        if (nbytes == 0) {
                            // connection closed
                            printf("selectserver: socket %d hung up\n", i);
                        } else {
                            perror("recv");
                        }
                        close(i); // bye!
                        FD_CLR(i, &amp;master); // remove from master set
                    } else {
                        // we got some data from a client
                        for(j = 0; j &lt;= fdmax; j++) {
                            // send to everyone!
                            if (FD_ISSET(j, &amp;master)) {
                                // except the listener and ourselves
                                if (j != listener &amp;&amp; j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got new incoming connection
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!
    
    return 0;
}</pre>


<p>Обрати внимание, что в коде есть два множества файловых дескрипторов:
<i><tt class="var">master</tt></i> и <i><tt class="var">read_fds</tt></i>.  Первое, 
 <i><tt class="var">master</tt></i>, содержит все дескрипторы сокетов, которые на данный момент соединены, а также все дескрипторы сокетов, 
 которые ожидают нового подключения.</p>

<p>Причина, по которой у меня есть множество <i><tt class="var">master</tt></i> в том, что 
<b><tt class="func">select()</tt></b> <i>изменяет</i> переданное множество, чтобы указать, какие сокеты готовы читать. 
Поскольку я должен следать за соединениями между вызовами <b><tt class="func">select()</tt></b>, 
я должен сохранить эти данные где-то в другом месте. В последний момент, я копирую 
<i><tt class="var">master</tt></i> в <i><tt class="var">read_fds</tt></i>, и затем вызываю <b><tt class="func">select()</tt></b>.</p>

<p>Но разве это не означает, что каждый раз, когда я получаю новое соединение, я должен добавить его в 
 <i><tt class="var">master</tt></i>? Именно так! И каждый раз, когда подключение закрывается, я также должен удалить его из 
 <i><tt class="var">master</tt></i></p>

<p>Заметь, что я проверяю, когда сокет <i><tt class="var">listener</tt></i>
будет готов к чтению. Когда это происходит, это значит, что у меня есть новое ожидающее подключение, и я 
 принимаю(<b><tt class="func">accept()</tt></b>) его и затем добавляю в множество 
<i><tt class="var">master</tt></i>. Точно так же, когда клиентское соединение готово к чтению и <b><tt class="func">recv()</tt></b> 
возвращает <tt class="const">0</tt>, я знаю, что клиент закрыл соединение и я должен удалить его из <i><tt class="var">master</tt></i>.</p>

<p>Если же <b><tt class="func">recv()</tt></b> от клиента вернул не ноль, я знаю, что данные были получены. Тогда я беру их, а затем бегу 
по всему <i><tt class="var">master</tt></i> и отправляю эти данные всем остальным подключенным клиентам.</p>

<p>И это, друзья мои, чуть менее простое описание всемогущего вызова <b><tt class="func">select()</tt></b>.</p>

<p>В дополнение, хочу сказать, что существует другая функция, которая называется <a name="indexId434909-156"></a><b><tt class="func">poll()</tt></b>, которая ведёт себя очень похоже, но использует другой механизм работы с множествами файловых дескрипторов. <a href="pollman.html">Зацени!</a></p>









<h3 class="sect2title">7.3. <a name="sendall">Обработка частичного <b><tt class="titlefunc">send()</tt></b>s</a></h3>


<p>Если ты помнишь, в секции <a href="syscalls.html#sendrecv">о
<b><tt class="func">send()</tt></b></a>, я говорил о том, что 
<b><tt class="func">send()</tt></b> может отправить не все байты из тех, что ты его попросил. 
Именно так, ты хотел, чтобы он отправил 512 байт, но он вернул 412. А что сталось с оставшимися 100 байтами?</p>

<p>Они всё ещё остались в буфере, который ты передавал функции. По причинам, не зависящим от тебя, ядро решило не отправлять 
все данные одним куском, и теперь, мой друг, на твоих плечах лежит ответственность за доотправку оставшегося.</p>

<p><a name="indexId434909-157"></a>Ты можешь написать для этого функцию, например, такую:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // how many bytes we've sent
    int bytesleft = *len; // how many we have left to send
    int n;

    while(total &lt; *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // return number actually sent here

    return n==-1?-1:0; // return -1 on failure, 0 on success
} 
</pre>


<p>В этом примере, <i><tt class="var">s</tt></i> это сокет, в который ты хочешь послать данные, 
<i><tt class="var">buf</tt></i> - указатель на буфер, содержащий данные, и
 <i><tt class="var">len</tt></i> - указатель на <nobr><tt class="type">int</tt></nobr>, содержащий 
 количество байт в буфере.</p>

<p>Эта функция возвращает <tt class="const">-1</tt> в случае ошибки (и устанавливает 
<i><tt class="var">errno</tt></i>, поскольку вызывает 
<b><tt class="func">send()</tt></b>.)  Также, количество байт, отправленных на самом деле возвращается в <i><tt class="var">len</tt></i>.  
Это будет то же количество байт, что ты попросил отправить, если во время отправки не произошло ошибки.
<b><tt class="func">sendall()</tt></b> сделает всё что возможно, пыхтя и отдуваясь, лишь бы отправить данные, 
но если произойдёт ошибка - она вернёт управление тебе.</p>

<p>Для полноты картины, вот пример вызова такой функции:</p>

<pre class="code">char buf[10] = "Beej!";
int len;

len = strlen(buf);
if (sendall(s, buf, &amp;len) == -1) {
    perror("sendall");
    printf("We only sent %d bytes because of the error!\n", len);
} 
</pre>


<p>А что происходит у получателя, когда приходит часть пакета? Если пакеты имеют переменную длину, 
как получатель узнает, когда закончился один пакет и начался другой? Да, в реальном мире всё сложно.
<a name="indexId434909-158"></a> Тебе, видимо, нужно будет <a name="indexId434909-159"></a><i>инкапсулировать</i> (можешь вспомнить, что это, перечитав <a href="theory.html#lowlevel">раздел о инкапсуляции данных</a>.) эту информацию внутри пакета. Читай дальше, если хочешь подробностей!</p>









<h3 class="sect2title">7.4. <a name="serialization">Сериализация—Как Паковать Данные</a></h3>


<p><a name="indexId434909-160"></a>Ты, наверное, заметил, что отправлять по сети текст довольно просто. 
Но что, если тебе нужно отправить "двоичные данные", например
 <nobr><tt class="type">int</tt></nobr>ы, или <nobr><tt class="type">float</tt></nobr>ы? Похоже, у тебя есть несколько вариантов. </p>

<ol>

<li>Перевести число в текст функцией навроде 
<b><tt class="func">sprintf()</tt></b>, а затем отправить текст. Получатель распарсит текст назад, используя обратную функцию, 
например <b><tt class="func">strtol()</tt></b>.</li>


<li>Просто послать сырые данные, передав указатель на данные в 
<b><tt class="func">send()</tt></b>.</li>


<li>Закодировать число в некоторую сжатую двоичную форму. Получатель раскодирует эту форму.</li>

</ol>


<p>Только сегодня и только сейчас!</p>

<p>[<i>Занавес открывается</i>]</p>

<p>Beej говорит "Я предпочитаю Метод 3!"</p>

<p>[<i>КОНЕЦ</i>]</p>

<p>(Перед тем, как я начну рассказывать серьёзно, я должен сказать тебе, что
существуют библиотеки, которые делают то же самое, и создать свою, 
притом переносимую и без ошибок - это довольно сложно. Поэтому поищи и сделай домашнюю работу, 
перед тем как решить, что будешь реализовывать это самостоятельно. Я включил информацию об этом для 
тех, кто очень хочет знать, как это работает.)</p>

<p>На самом деле, все вышеописанные методы имеют свои плюсы и минусы, но, 
как я уже сказал, в основном, я предпочитаю третий метод. Но для начала давай поговорим о 
плюсах и минусах двух оставшихся.</p>

<p>Первый метод, перевод числа в строку перед отправкой, хорош тем, что 
ты можешь легко печатать и читать данные, которые приходят по проводам. Иногда, 
человекочитаемый протокол очень хорош для использования в ситуации, когда канал передачи 
не слишком загружен, например, в случае <a name="indexId434909-161"></a><a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" target="_blank">Internet Relay Chat (IRC)</a>.
Тем не менее, он имеет большой недостаток, что конвертировать число в строку довольно долго, и строка 
занимает гораздо больше места, чем исходное число!</p>

<p>Метод два: отправить сырые данные. Он довольно простой (но и опасный!): 
просто взять указатель на данные, которые нужно отправить, и передать его функции 
<b><tt class="func">send()</tt></b>.</p>

<pre class="code">double d = 3490.15926535;

send(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */</pre>


<p>Адресат сможет получить его так:</p>

<pre class="code">double d;

recv(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */</pre>


<p>Быстро, просто-что в нём плохого? Ну, выходит так, что не все архитектуры представляют <nobr><tt class="type">double</tt></nobr> (или
 <nobr><tt class="type">int</tt></nobr>, коли на то пошло) точно так же побитово, или даже в том же порядке байт! Этот код
  несомненно непереносим. (Хотя, может быть, тебе не нужна переносимость, тогда этот способ будет для тебя хорошим и быстрым.)</p>

<p>При паковке целочисленных типов, мы уже видели, что функции навроде <a name="indexId434909-162"></a><b><tt class="func">htons()</tt></b> 
могут поддерживать переносимость, переводя числа в <a name="indexId434909-163"></a>
Сетевой Порядок Байт, и почему это Правильно делать. К сожалению, не существует таких же функций для чисел с плавающей точкой. Неужели 
надежды нет?</p>

<p>Не бойся!  (Что, ты и не испугался? Нет? Даже самую чуточку не испугался?) 
Есть кое-что, что мы можем сделать: мы можем запаковать (или "разместить",
или "сериализовать", или назвать это ещё миллиардом других имён) данные в известный двоичный формат, который 
получатель сможет распаковать на своей стороне.</p>

<p>Что я подразумеваю под "известным двоичным форматом"? Мы уже знаем пример функции <b><tt class="func">htons()</tt></b> не так ли? 
Она изменяет (или "кодирует", если хочешь представлять это таким образом) число из любого формата владельца в Сетевой Порядок Байт. 
Чтобы вернуть обратно(раскодировать) число, получатель вызывает <b><tt class="func">ntohs()</tt></b>.</p>

<p>Но разве я не говорил только что, что нет такой же функции для всех остальных 
не-целочисленных типов? Да. Говорил. И поскольку в C нет стандартного способа сделать это, это является проблемой.</p>

<p>Всё что нужно сделать, это запаковать данные в известный формат и отправить его по сети, а после раскодировать. К примеру, чтобы запаковать 
<nobr><tt class="type">float</tt></nobr>ы, вот быстрая <a href="http://beej.us/guide/bgnet/examples/pack.c" target="_blank"> и простая
 функция с большим простором для улучшений:</a></p>

<pre class="code">#include &lt;stdint.h&gt;

uint32_t htonf(float f)
{
    uint32_t p;
    uint32_t sign;

    if (f &lt; 0) { sign = 1; f = -f; }
    else { sign = 0; }
        
    p = ((((uint32_t)f)&amp;0x7fff)&lt;&lt;16) | (sign&lt;&lt;31); // whole part and sign
    p |= (uint32_t)(((f - (int)f) * 65536.0f))&amp;0xffff; // fraction

    return p;
}

float ntohf(uint32_t p)
{
    float f = ((p&gt;&gt;16)&amp;0x7fff); // whole part
    f += (p&amp;0xffff) / 65536.0f; // fraction

    if (((p&gt;&gt;31)&amp;0x1) == 0x1) { f = -f; } // sign bit set

    return f;
}</pre>


<p>Код выше - это что-то вроде наивной реализации, которая упаковывает 
<nobr><tt class="type">float</tt></nobr> в 32-битное число. Старший бит (31) используется для хранения знака числа ("1" значит, что число отрицательное), следующие 15 бит (30-16) хранят целую часть <nobr><tt class="type">float</tt></nobr>а. 
И наконец, оставшиеся биты (15-0) хранят дробную чать числа.</p>

<p>Пользоваться функцией очень просто:</p>

<pre class="code">#include &lt;stdio.h&gt;

int main(void)
{
    float f = 3.1415926, f2;
    uint32_t netf;

    netf = htonf(f);  // convert to "network" form
    f2 = ntohf(netf); // convert back to test

    printf("Original: %f\n", f);        // 3.141593
    printf(" Network: 0x%08X\n", netf); // 0x0003243F
    printf("Unpacked: %f\n", f2);       // 3.141586

    return 0;
}</pre>


<p>Плюсом является то, что функция небольшая, простая и быстрая. Минусы - 
неэффективная по памяти, и диапазон хранимых чисел сильно ограничен - попробуй передать число, большее, чем 32767 - тебе 
вряд ли понравится результат. Также ты можешь заметить, что в результате несколько последних десятичных разрядов переданы некорректно.</p>

<p>Как нам поступить? Ну, <i>Стандарт</i> для хранения чисел с плавающей точкой, известен 
как <a name="indexId434909-164"></a><a href="http://en.wikipedia.org/wiki/IEEE_754" target="_blank">IEEE-754</a>. 
Большинство компьютеров используют этот формат для выполнения нецелочисленных действий с числами, поэтому, строго говоря, в этом случае 
кончертация не необходима. Но если ты хочешь, чтобы твой код был переносим, тебе не обязательно предполагать это. (С другой стороны, если ты хочешь, чтобы все работало быстро, тебе нужно оптимизировать функцию для каждой платформы, в которой не нужно ничего конвертировать. Именно так сделаны функция <b><tt class="func">htons()</tt></b> и иже с ней.)</p>

<p><a href="http://beej.us/guide/bgnet/examples/ieee754.c" target="_blank">Вот код, который кодирует 
<nobr><tt class="type">float</tt></nobr> ы и <nobr><tt class="type">double</tt></nobr>ы в IEEE-754</a>.  (В основном-он 
не кодирует NaNы и бесконечности, но он может быть модифицирован, чтобы поддерживать это.)</p>

<pre class="code">#define pack754_32(f) (pack754((f), 32, 8))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (unpack754((i), 32, 8))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(long double f, unsigned bits, unsigned expbits)
{
    long double fnorm;
    int shift;
    long long sign, exp, significand;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (f == 0.0) return 0; // get this special case out of the way

    // check sign and begin normalization
    if (f &lt; 0) { sign = 1; fnorm = -f; }
    else { sign = 0; fnorm = f; }

    // get the normalized form of f and track the exponent
    shift = 0;
    while(fnorm &gt;= 2.0) { fnorm /= 2.0; shift++; }
    while(fnorm &lt; 1.0) { fnorm *= 2.0; shift--; }
    fnorm = fnorm - 1.0;

    // calculate the binary form (non-float) of the significand data
    significand = fnorm * ((1LL&lt;&lt;significandbits) + 0.5f);

    // get the biased exponent
    exp = shift + ((1&lt;&lt;(expbits-1)) - 1); // shift + bias

    // return the final answer
    return (sign&lt;&lt;(bits-1)) | (exp&lt;&lt;(bits-expbits-1)) | significand;
}

long double unpack754(uint64_t i, unsigned bits, unsigned expbits)
{
    long double result;
    long long shift;
    unsigned bias;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (i == 0) return 0.0;

    // pull the significand
    result = (i&amp;((1LL&lt;&lt;significandbits)-1)); // mask
    result /= (1LL&lt;&lt;significandbits); // convert back to float
    result += 1.0f; // add the one back on

    // deal with the exponent
    bias = (1&lt;&lt;(expbits-1)) - 1;
    shift = ((i&gt;&gt;significandbits)&amp;((1LL&lt;&lt;expbits)-1)) - bias;
    while(shift &gt; 0) { result *= 2.0; shift--; }
    while(shift &lt; 0) { result /= 2.0; shift++; }

    // sign it
    result *= (i&gt;&gt;(bits-1))&amp;1? -1.0: 1.0;

    return result;
}</pre>


<p>Я добавил несколько удобных макросов в начале, для паковки и распаковки 32-битных (например, <nobr><tt class="type">float</tt></nobr>) и 64-битных (например, <nobr><tt class="type">double</tt></nobr>) чисел, но функция <b><tt class="func">pack754()</tt></b> может вызываться на любом из этих типов, потому, что ей можно указать сколько бит <i><tt class="var">bits</tt></i> кодировать
 (<i><tt class="var">expbits</tt></i> из них зарезервированы для нормализованной экспоненты числа.)</p>

<p>Пример использования:</p>

<pre class="code">
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt; // defines uintN_t types
#include &lt;inttypes.h&gt; // defines PRIx macros

int main(void)
{
    float f = 3.1415926, f2;
    double d = 3.14159265358979323, d2;
    uint32_t fi;
    uint64_t di;

    fi = pack754_32(f);
    f2 = unpack754_32(fi);

    di = pack754_64(d);
    d2 = unpack754_64(di);

    printf("float before : %.7f\n", f);
    printf("float encoded: 0x%08" PRIx32 "\n", fi);
    printf("float after  : %.7f\n\n", f2);

    printf("double before : %.20lf\n", d);
    printf("double encoded: 0x%016" PRIx64 "\n", di);
    printf("double after  : %.20lf\n", d2);

    return 0;
}</pre>


<p>Вывод вышеприведённого кода:</p>

<pre class="screen">float before : 3.1415925
float encoded: 0x40490FDA
float after  : 3.1415925

double before : 3.14159265358979311600
double encoded: 0x400921FB54442D18
double after  : 3.14159265358979311600</pre>


<p>Возможно, у тебя есть ещё один вопрос: как паковать 
<nobr><tt class="type">struct</tt></nobr>ы? К сожалению для тебя, компилятор по стандарту имеет право 
ставить пропуски в памяти в любом месте <nobr><tt class="type">struct</tt></nobr>а, 
и это значит, что если ты будешь отправлять объект просто через указатель - это не будет переносимо. 
(Ты ещё не устал от слов "не можешь сделать то", "не можешь сделать это"? Цитируя друга, "Если что-то идёт не так, я виню Microsoft." 
Именно эта проблема может и не вина Microsoft, но высказывание друга - чистая правда.)</p>

<p>Мы отвлеклись: лучший способ послать <nobr><tt class="type">struct</tt></nobr> по сети - это запаковать 
каждое поле независимо и затем распаковать всё обратно в 
<nobr><tt class="type">struct</tt></nobr> по прибытии.</p>

<p>Это же куча работы, скажешь ты. Да, куча. Ты можешь написать функцию-помощника, которая будет помогать тебе паковать данные. Это будет весело! Серьёзно!</p>

<p>В книгу "<a href="http://cm.bell-labs.com/cm/cs/tpop/" target="_blank">The Practice of
Programming</a>" за авторством Kernighan и Pike, они реализуют 
<b><tt class="func">printf()</tt></b>-подобные функции, названные <b><tt class="func">pack()</tt></b>  и
<b><tt class="func">unpack()</tt></b> которые делают ровно то же самое. Я сослался на них, но эти функции определённо не лежат онлайн вместе 
с оставшимися исходниками из книги.</p>

<p>(The Practice of Programming - это отличное чтение. Бог спасает котёнка каждый раз, когда я его рекомендую.)</p>

<p>В этом месте я собираюсь оставить ссылку на BSD-лицензированный <a href="http://tpl.sourceforge.net/" target="_blank">Typed Parameter Language C API</a> который я никогда не использовал, но выглядит он очень солидно. Программисты Python и Perl, вероятно, захотят найти аналоги функций <b><tt class="func">pack()</tt></b> и
<b><tt class="func">unpack()</tt></b> на своём языке. И, конечно, в Java есть старый добрый интерфейс Serializable, 
который может использоваться таким же образом.</p>

<p>Но если ты хочешь написать свою собственную пакующую утилиту на C, трюк Кернигана и Пайка состоит в том, чтобы использовать списки  аргументов переменного размера для создания <b><tt class="func">printf()</tt></b>-подобных функций для упаковки пакетов. <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">Вот вариант, который я написал сам</a>, надеюсь, его достаточно, чтобы вы поняли, как это работает.</p>

<p>(Этот код ссылается на функции <b><tt class="func">pack754()</tt></b>,указанные выше.
Функции <b><tt class="func">packi*()</tt></b> работают как и семейство <b><tt class="func">htons()</tt></b>, 
не считая того, что они пакуют в массив <nobr><tt class="type">char</tt></nobr>ов вместо другого <nobr><tt class="type">integer</tt></nobr>а.)</p>

<pre class="code">#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

// various bits for floating point types--
// varies for different architectures
typedef float float32_t;
typedef double float64_t;

/*
** packi16() -- store a 16-bit int into a char buffer (like htons())
*/ 
void packi16(unsigned char *buf, unsigned int i)
{
    *buf++ = i&gt;&gt;8; *buf++ = i;
}

/*
** packi32() -- store a 32-bit int into a char buffer (like htonl())
*/ 
void packi32(unsigned char *buf, unsigned long i)
{
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())
*/ 
unsigned int unpacki16(unsigned char *buf)
{
    return (buf[0]&lt;&lt;8) | buf[1];
}

/*
** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())
*/ 
unsigned long unpacki32(unsigned char *buf)
{
    return (buf[0]&lt;&lt;24) | (buf[1]&lt;&lt;16) | (buf[2]&lt;&lt;8) | buf[3];
}

/*
** pack() -- store data dictated by the format string in the buffer
**
**  h - 16-bit              l - 32-bit
**  c - 8-bit char          f - float, 32-bit
**  s - string (16-bit length is automatically prepended)
*/ 
int32_t pack(unsigned char *buf, char *format, ...)
{
    va_list ap;
    int16_t h;
    int32_t l;
    int8_t c;
    float32_t f;
    char *s;
    int32_t size = 0, len;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'h': // 16-bit
            size += 2;
            h = (int16_t)va_arg(ap, int); // promoted
            packi16(buf, h);
            buf += 2;
            break;

        case 'l': // 32-bit
            size += 4;
            l = va_arg(ap, int32_t);
            packi32(buf, l);
            buf += 4;
            break;

        case 'c': // 8-bit
            size += 1;
            c = (int8_t)va_arg(ap, int); // promoted
            *buf++ = (c&gt;&gt;0)&amp;0xff;
            break;

        case 'f': // float
            size += 4;
            f = (float32_t)va_arg(ap, double); // promoted
            l = pack754_32(f); // convert to IEEE 754
            packi32(buf, l);
            buf += 4;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = strlen(s);
            size += len + 2;
            packi16(buf, len);
            buf += 2;
            memcpy(buf, s, len);
            buf += len;
            break;
        }
    }

    va_end(ap);

    return size;
}

/*
** unpack() -- unpack data dictated by the format string into the buffer
*/
void unpack(unsigned char *buf, char *format, ...)
{
    va_list ap;
    int16_t *h;
    int32_t *l;
    int32_t pf;
    int8_t *c;
    float32_t *f;
    char *s;
    int32_t len, count, maxstrlen=0;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'h': // 16-bit
            h = va_arg(ap, int16_t*);
            *h = unpacki16(buf);
            buf += 2;
            break;

        case 'l': // 32-bit
            l = va_arg(ap, int32_t*);
            *l = unpacki32(buf);
            buf += 4;
            break;

        case 'c': // 8-bit
            c = va_arg(ap, int8_t*);
            *c = *buf++;
            break;

        case 'f': // float
            f = va_arg(ap, float32_t*);
            pf = unpacki32(buf);
            buf += 4;
            *f = unpack754_32(pf);
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = unpacki16(buf);
            buf += 2;
            if (maxstrlen &gt; 0 &amp;&amp; len &gt; maxstrlen) count = maxstrlen - 1;
            else count = len;
            memcpy(s, buf, count);
            s[count] = '\0';
            buf += len;
            break;

        default:
            if (isdigit(*format)) { // track max str len
                maxstrlen = maxstrlen * 10 + (*format-'0');
            }
        }

        if (!isdigit(*format)) maxstrlen = 0;
    }

    va_end(ap);
}</pre>


<p>А <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">вот и демо-программа</a>, использующая код, описанный выше, 
она пакует некоторые данные в 
<i><tt class="var">buf</tt></i>, а затем распаковывает эти данные обратно в переменные. Обрати внимание, что 
при вызове <b><tt class="func">unpack()</tt></b> со строковым аргументов(флаг формата 
"<tt class="const">s</tt>"), будет мудрым писать максимальную длину такой строки перед флагом, чтобы предотвратить переполнение буфера, 
например "<tt class="const">96s</tt>". Будь осторожен, распаковывая данные, пришедшие по сети - злоумышленник мог специально послать 
некорректно сформированные данные, чтобы атаковать твой компьютер!</p>

<pre class="code">#include &lt;stdio.h&gt;

// various bits for floating point types--
// varies for different architectures
typedef float float32_t;
typedef double float64_t;

int main(void)
{
    unsigned char buf[1024];
    int8_t magic;
    int16_t monkeycount;
    int32_t altitude;
    float32_t absurdityfactor;
    char *s = "Great unmitigated Zot!  You've found the Runestaff!";
    char s2[96];
    int16_t packetsize, ps2;

    packetsize = pack(buf, "chhlsf", (int8_t)'B', (int16_t)0, (int16_t)37, 
            (int32_t)-5, s, (float32_t)-3490.6677);
    packi16(buf+1, packetsize); // store packet size in packet for kicks

    printf("packet is %" PRId32 " bytes\n", packetsize);

    unpack(buf, "chhl96sf", &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,
        &amp;absurdityfactor);

    printf("'%c' %" PRId32" %" PRId16 " %" PRId32
            " \"%s\" %f\n", magic, ps2, monkeycount,
            altitude, s2, absurdityfactor);

    return 0;
}</pre>


<p>Пишешь ли ты свой код, или используешь уже написанный, лучше
 будет иметь общий набор функций паковки данных, для того, чтобы возможно было выполнять проверку ошибок, чем каждый раз вручную паковать каждый бит.</p>

<p>Когда пакуешь данные, какой формат лучше использовать? Отличный вопрос. 
К счастью, существует <a name="indexId434909-165"></a><a href="http://tools.ietf.org/html/rfc4506" target="_blank">RFC 4506</a>, the External Data
Representation Standard, в котором уже определены двоичные форматы различных типов, например чисел с плавающе точкой, 
целых чисел, массивов, сырых данных и т.д. Я рекомендую следовать стандарту, если ты собираешься самостоятельно передавать данные. 
Но ты не обязан это делать. Полиция Пакетов не стоит с оружием за твоей дверью. По крайней мере, я <i>думаю</i>, что не стоит.</p>

<p>В любом случае, так или иначе кодировать данные перед отправкой - это хорошая идея!</p>









<h3 class="sect2title">7.5. <a name="sonofdataencap">Инкапсуляция Данных, часть 2</a></h3>


<p>Что на самом деле означает инкапсулировать данные? В простейшем случае это значит, что ты цепляешь к данным заголовок со служебной информацией.</p>

<p>И как же должен выглядеть такой заголовок? Ну, это просто некоторые двоичные данные, в которые зашито что-то важное для текущей передачи данных.</p>

<p>Вау. Звучит как-то мутно.</p>

<p>Окей. К примеру, скажем, у тебя есть многопользовательский чат, который использует 
<tt class="const">SOCK_STREAM</tt>ы. Когда пользователь печатает ("говорит")
что-то, нужно отправить два куска информации: что было сказано и кто это сказал.</p>

<p>И это всё? "В чём тут подвох?" спросишь ты.</p>

<p>А подвох в том, что сообщения могут быть переменной длины. Один пользователь по имени "tom" может сказать "Hi", а другой 
пользователь, "Benjamin", может сказать "Hey guys what is up?"</p>

<p>Если ты просто отправишь(<b><tt class="func">send()</tt></b>) эти сообщения, то пришедший клиенту поток может выглядеть так:</p>

<pre class="screen">t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?</pre>


<p>И так далее. Как клиент поймёт, когда заканчивается одно сообщение и начинается другое? Ты можешь, например, сделать все 
сообщения фиксированной длины и просто вызвать  уже нами <a href="advanced.html#sendall">реализованную</a> функцию <a name="indexId434909-166"></a><b><tt class="func">sendall()</tt></b>. Но тогда ты будешь неэффективно использовать канал! Ты же не хочешь отправлять 1024 байта исключительно ради того, чтобы передать, что "том" сказал "Привет".</p>

<p>Поэтому мы <i>инкапсулируем</i> данные в структуру с небольшим заголовком. И клиент, и сервер будут знать, как 
запаковать и распаковать (иногда это обозначается как "marshal" и "unmarshal") эти данные. 
Возможно ты не заметил, но мы уже начали определять <i>протокол</i>, по которому общаются клиент и сервер!</p>

<p>В нашем случае, пусть у нас имя пользователя будет иметь фиксированную длину в 8 байт, выровненные символами <tt class="const">'\0'</tt>. 
И затем, предположим, что данные имеют переменную длину, максимум 128 символов. Давай рассмотрим простую структуру пакета, которую мы можем использовать в нашей ситуации:</p>

<ol>


<li><tt class="tt">len</tt> (1 байт, беззнаковый)—Полная длина пакета, включая восьмибайтовое имя пользователя и сообщение.</li>


<li><tt class="tt">name</tt> (8 байт)—Имя пользователя, выровненное NUL-ами по необходимости.</li>


<li><tt class="tt">chatdata</tt>
(<i>n</i> байт)—Непосредственно данные, максимум 128 байт. Длина пакета равна длине этих данных + 8(длина имени)</li>


</ol>


<p>Почему я выбрал именно 8 байт и 128 байт для максимального размера полей. Я просто ткнул пальцем в небо, 
предположив что их будет достаточно. Возможно, 8 байт это слишком мало для твоих нужд, и у тебя может быть 30 байт на имя, или ещё сколько-то. 
Выбор за тобой.</p>

<p>Используя определение пакета, данное выше, первый пакет будет содержать следующую информацию (в hex и ASCII):</p>

<pre class="screen">   0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i
</pre>


<p>And the second is similar:</p>

<pre class="screen">   18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...
</pre>


<p>(Конечно, длина хранится Сетевом Порядке Байт. Правда, в этом случае у нас всего один байт, поэтому порядок байт не имеет 
значения, но в общем случае все целые числа должны быть сохранены в Сетевом Порядке Байт.)</p>

<p>При отправке данных нужно позаботиться о безопасности и использовать функцию навроде 
<a href="advanced.html#sendall"><b><tt class="func">sendall()</tt></b></a>, чтобы быть уверенными, что все данные отправлены, 
даже если они не могут быть отправлены за один вызов <b><tt class="func">send()</tt></b>.</p>

<p>Точно так же, при получении данных необходимо выполнить некоторую дополнительную работу. Из соображений безопасности, 
тебе стоит предполагать, что ты можешь получить пакет частично (например, мы могли получить
 "<tt class="tt">18 42 65
6E 6A</tt>" от Бенджамина при одном вызове <b><tt class="func">recv()</tt></b>). Нам нужно вызывать 
<b><tt class="func">recv()</tt></b> снова и снова, пока пакет не будет полностью получен.</p>

<p>Но как? Ну, мы всегда знаем полный размер пакета, поскольку он находится в начале пакета и 
обязательно будет получен, если <b><tt class="func">recv()</tt></b> вернул хоть что-нибудь. Также мы знаем, что максимальный размер пакета 
равен 1+8+128, или 137 байт (потому что мы так задали наш пакет.)</p>

<p>Есть ещё несколько вещей, которые ты можешь сделать при такой структуре пакета. Например, первым вызовом <b><tt class="func">recv()</tt></b> ты можешь получить только длину пакета. После этого, ты можешь снова вызвать её, но на этот раз 
передать ей оставшуюся длину пакета (вызывать необходимо цикле, чтобы гарантированно получить все данные или ошибку). 
Плюсом этого метода является то, что тебе не нужно выделять буфер большего размера, чем необходимо для одного пакета, а минусом - 
то, что тебе необходимо как минимум дважды вызвать <b><tt class="func">recv()</tt></b>, чтобы получить все данные.</p>

<p>Также можно просто всегда вызывать <b><tt class="func">recv()</tt></b> и просить у него максимальный 
размер пакета в байтах. Тогда что бы ты ни получил, запиши это в конец буфера и проверь, что буфер содержит пакет целиком. Конечно, 
в этом случае ты можешь зацепить часть следующего пакета и это необходимо учесть.</p>

<p>Для этого можно выделить массив, достаточно большой, чтобы вместить два пакета. Это будет твой рабочий буфер, из которого ты 
будешь восстанавливать пакеты после их прибытия.</p>

<p>Каждый раз, когда ты получаешь данные, ты можешь записывать их в конец буфера, и проверять, содержит ли буфер пакет 
целиком. То есть, количество байт в буфере больше либо равно длине, записаной в заголовке (+1, потому что длина в заголовке не включает в себя непосредственно байт длины.) 
Если количество байт в буфере меньше 1, то, очевидно, пакет не завершён. Нужно рассмотреть этот случай отдельно, поскольку тогда первый байт буфера это мусор, и нельзя считать его длиной пакета.</p>

<p>Как только пакет полон, можешь делать с ним то, что нужно. Конечно, его нужно удалить из буфера.</p>

<p>Фух! Ты ещё обдумываешь то, что прочитал? Тогда вот тебе второй удар из двойки: 
ты мог прочитать больше длины одного пакета за один вызов <b><tt class="func">recv()</tt></b>. 
Именно так, теперь у тебя в буфере один целый пакет и один неполный. Вот ведь незадача. (Но ведь для этого ты и делал свой буфер 
размером в две максимальные длины пакета!)</p>

<p>Поскольку ты знаешь длину первого пакета из заголовка, и ты знаешь, сколько байт в рабочем буфере, 
ты можешь посчитать, сколько байт в буфере относится к неполному пакету. Тогда, ты можешь сдвинуть эти байты в начало буфера, 
и снова быть готовым к следующим вызовам <b><tt class="func">recv()</tt></b>.</p>

<p>(Некоторые из читателей заметят, что перемещение части второго пакета в начало может 
занять определённое время, и программа может быть сделана так, чтобы копировать было не нужно, если 
будет использовать циклический буфер. К сожалению для остальных, разговор о циклических буферах выходит за рамки данной статьи. 
Но если тебе интересно, хватай книгу о структурах данных и читай её.)</p>

<p>Я никогда не говорил что это будет просто. Хорошо, я говорил, что будет просто. И так оно и есть; просто 
тебе нужно попрактиковаться и скоро всё это будет казаться тебе очевидным. Именем 
<a name="indexId434909-167"></a>Эскалибура, клянусь, что это так!</p>

 






<h3 class="sect2title">7.6. <a name="broadcast">Broadcast Packets—Hello, World!</a></h3>


<p>So far, this guide has talked about sending data from one host to one
other host.  But it is possible, I insist, that you can, with the proper
authority, send data to multiple hosts <i>at the same time</i>!</p>

<p>With <a name="indexId434909-168"></a>UDP (only UDP, not TCP) and standard IPv4, this
is done through a mechanism called <a name="indexId434909-169"></a><i>broadcasting</i>.  With IPv6, broadcasting isn't
supported, and you have to resort to the often superior technique of
<i>multicasting</i>, which, sadly I won't be discussing at this
time.   But enough of the starry-eyed future—we're stuck in the
32-bit present.</p>

<p>But wait!  You can't just run off and start broadcasting willy-nilly;
You have to <a name="indexId434909-170"></a>set the socket option <a name="indexId434909-171"></a><tt class="const">SO_BROADCAST</tt> before you can send a
broadcast packet out on the network.  It's like a one of those little
plastic covers they put over the missile launch switch!  That's just how
much power you hold in your hands!</p>

<p>But seriously, though, there is a danger to using broadcast packets,
and that is: every system that receives a broadcast packet must undo all
the onion-skin layers of data encapsulation until it finds out what port
the data is destined to.  And then it hands the data over or discards
it.  In either case, it's a lot of work for each machine that receives
the broadcast packet, and since it is all of them on the local network,
that could be a lot of machines doing a lot of unnecessary work.  When
the game Doom first came out, this was a complaint about its network
code.</p>

<p>Now, there is more than one way to skin a cat... wait a minute.  Is
there really more than one way to skin a cat?  What kind of expression
is that?  Uh, and likewise, there is more than one way to send a
broadcast packet.  So, to get to the meat and potatoes of the whole
thing: how do you specify the destination address for a broadcast
message?  There are two common ways:</p>

<ol>

<li>Send the data to a specific subnet's broadcast address.  This is the
subnet's network number with all one-bits set for the host portion of
the address.  For instance, at home my network is 192.168.1.0, my
netmask is 255.255.255.0, so the last byte of the address is my host
number (because the first three bytes, according to the netmask, are the
network number).  So my broadcast address is 192.168.1.255.  Under Unix,
the <b class="com">ifconfig</b> command will actually give you all this data.
(If you're curious, the bitwise logic to get your broadcast address is
<i><tt class="var">network_number</tt></i> OR (NOT <i><tt class="var">netmask</tt></i>).)  You can send
this type of broadcast packet to remote networks as well as your local
network, but you run the risk of the packet being dropped by the
destination's router.  (If they didn't drop it, then some random smurf
could start flooding their LAN with broadcast traffic.)</li>


<li>Send the data to the "global" broadcast address.  This is <a name="indexId434909-172"></a>255.255.255.255, aka
<a name="indexId434909-173"></a><tt class="const">INADDR_BROADCAST</tt>.  Many
machines will automatically bitwise AND this with your network number to
convert it to a network broadcast address, but some won't.  It varies.
Routers do not forward this type of broadcast packet off your local
network, ironically enough.</li>


</ol>


<p>So what happens if you try to send data on the broadcast address
without first setting the <tt class="const">SO_BROADCAST</tt> socket option?
Well, let's fire up good old <a href="clientserver.html#datagram"><b class="com">talker</b> and
<b class="com">listener</b></a> and see what happens.</p>

<pre class="screen">$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</pre>


<p>Yes, it's not happy at all...because we didn't set the
<tt class="const">SO_BROADCAST</tt> socket option.  Do that, and now you can
<b><tt class="func">sendto()</tt></b> anywhere you want!</p>

<p>In fact, that's the <i>only difference</i> between a UDP
application that can broadcast and one that can't.  So let's take the
old <b class="com">talker</b> application and add one section that sets the
<tt class="const">SO_BROADCAST</tt> socket option.  We'll call this program
<a href="http://beej.us/guide/bgnet/examples/broadcaster.c" target="_blank">
<i><tt class="var">broadcaster.c</tt></i></a>:</p>


<pre class="code">/*
** broadcaster.c -- a datagram "client" like talker.c, except
**                  this one can broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;
    int broadcast = 1;
    //char broadcast = '1'; // if that doesn't work, try this

    if (argc != 3) {
        fprintf(stderr,"usage: broadcaster hostname message\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // this call is what allows broadcast packets to be sent:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof broadcast) == -1) {
        perror("setsockopt (SO_BROADCAST)");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(their_addr.sin_zero, '\0', sizeof their_addr.sin_zero);

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof their_addr)) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes,
        inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</pre>



<p>What's different between this and a "normal" UDP client/server
situation?  Nothing!  (With the exception of the client being allowed to
send broadcast packets in this case.)  As such, go ahead and run the old
UDP <a href="clientserver.html#datagram"><b class="com">listener</b></a> program in one
window, and <b class="com">broadcaster</b> in another.  You should be now be
able to do all those sends that failed, above.</p>

<pre class="screen">$ broadcaster 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ broadcaster 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ broadcaster 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</pre>


<p>And you should see <b class="com">listener</b> responding that it got the
packets.  (If <b class="com">listener</b> doesn't respond, it could be because
it's bound to an IPv6 address.  Try changing the
<tt class="const">AF_UNSPEC</tt> in <i><tt class="var">listener.c</tt></i> to
<tt class="const">AF_INET</tt> to force IPv4.)</p>

<p>Well, that's kind of exciting.  But now fire up <b class="com">listener</b> on
another machine next to you on the same network so that you have two
copies going, one on each machine, and run <b class="com">broadcaster</b> again
with your broadcast address... Hey!  Both <b class="com">listener</b>s get the
packet even though you only called <b><tt class="func">sendto()</tt></b> once!
Cool!</p>

<p>If the <b class="com">listener</b> gets data you send directly to it, but not
data on the broadcast address, it could be that you have a <a name="indexId434909-174"></a>firewall on your local machine that is blocking the
packets.  (Yes, <a name="indexId434909-175"></a>Pat and <a name="indexId434909-176"></a>Bapper, thank
you for realizing before I did that this is why my sample code wasn't
working.  I told you I'd mention you in the guide, and here you are.  So
<i>nyah</i>.)</p>

<p>Again, be careful with broadcast packets.  Since every machine on the
LAN will be forced to deal with the packet whether it
<b><tt class="func">recvfrom()</tt></b>s it or not, it can present quite a load to the
entire computing network.  They are definitely to be used sparingly and
appropriately.</p>

 

<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="clientserver.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="faq.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>

</body>
</html>
