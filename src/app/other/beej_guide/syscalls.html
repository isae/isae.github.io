<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Системные вызовы или Провал</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="ip4to6.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="clientserver.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>


<h2 class="sect1title">5. <a name="syscalls">Системные вызовы или Провал</a></h2><hr class="mainsecthr"/>


<p>В этом разделе мы разберёмся с системными вызовами (и другими, библиотечными вызовами), которые позволят тебе получить доступ к функциям сети на машине с Unix, или любой другой, поддерживающей API сокетов (BSD,
Windows, Linux, Mac, или что там у тебя.) Если ты вызываешь эти функции, ядро выполняет всю работу за тебя автомагически.</p>

<p>Многим людям тяжело понять, в каком порядке эти штуки надо вызывать. Об этом не говорится в <b class="com">man</b>-страницах, как ты уже мог заметить. Чтобы исправить эту ужасную ситуацию, я постарался описать системные вызовы ниже в <i>точно</i> (примерно) таком порядке, как тебе и нужно вызывать их в своём коде.</p>

<p>Это, плюс немного образцов кода там и сям, немного молока и печенек(боюсь, тебе самому придётся о них позаботиться), немного сырых кишок и мужества - и ты сможешь посылать лучи с данными по всему Интернету как сын Джона Постела!</p>

<p><i>(Пожауйста, обрати внимание, что для краткости, в большинстве примеров кода ниже отсутствует необходимая проверка ошибок. Кроме того, предполагается, что вызов <b><tt class="func">getaddrinfo()</tt></b> продёт успешно и вернёт валидный элемент связного списка. Тем не менее, обе эти ситуации должным образом учтены в реальных программах, поэтому используй их как пример.)</i></p>






<h3 class="sect2title">5.1. <a name="getaddrinfo"><b><tt class="titlefunc">getaddrinfo()</tt></b>—Приготовиться к запуску!</a></h3>


<p><a name="indexId434909-91"></a>Это важная функция с большим количеством опций, но использовать её на самом деле довольно просто. Она помогает настроить <nobr><tt class="type">struct</tt></nobr>ы, которые далее тебе понадобятся.</p>

<p>Немного истории: раньше тебе нужно было использовать функцию <b><tt class="func">gethostbyname()</tt></b> для выполнения DNS-запросов. Далее тебе было необходимо вручную загрузить эту информацию в  <nobr><tt class="type">struct sockaddr_in</tt></nobr>, и использовать этот объект в своих вызовах.</p>

<p>К счастью, сейчас так делать не нужно. (Также, не стоит так делать, если ты пишешь код, который будет работать и с IPv4, и с IPv6!) В нашем современном мире у тебя есть функция <b><tt class="func">getaddrinfo()</tt></b>, которая делает всё, что тебе нужно за тебя, включая DNS and service - запросы(lookups), и, более того, формирует <nobr><tt class="type">struct</tt></nobr>ы, которые тебе нужны!</p>

<p>Давай посмотрим!</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node,     // e.g. "www.example.com" or IP
                const char *service,  // e.g. "http" or port number
                const struct addrinfo *hints,
                struct addrinfo **res);</pre>


<p>Ты передаёшь в эту функцию три входных параметра и она возвращает тебе указатель на связный список результатов, <i><tt class="var">res</tt></i>.</p>

<p><i><tt class="var">node</tt></i> - это имя хоста, к которому подсоединяемся или IP-адрес.</p>

<p>Далее следует параметр <i><tt class="var">service</tt></i>, который может быть номером порта, например "80", или именем сервиса (из <a href="http://www.iana.org/assignments/port-numbers" target="_blank">The IANA Port List</a> или файла <i><tt class="var">/etc/services</tt></i> на твоей Unix-машине), например "http", или "ftp", или "telnet", или "smtp" или что душа пожелает.</p>

<p>Наконец, параметр <i><tt class="var">hints</tt></i> указывает на <nobr><tt class="type">struct addrinfo</tt></nobr>, которую ты уже заполнил правильной информацией.</p>

<p>Вот пример вызова, если ты являешься сервером, который хочет слушать то, приходит на IP-адрес своего хоста, через порт 3490. Заметь, что этот код ничего не слушает, он только формирует объекты, которые мы будем использовать далее:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

if ((status = getaddrinfo(NULL, "3490", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of 1 or more struct addrinfos

// ... do everything until you don't need servinfo anymore ....

freeaddrinfo(servinfo); // free the linked-list</pre>


<p>Заметь, что я установил <i><tt class="var">ai_family</tt></i> в <tt class="const">AF_UNSPEC</tt>, говоря таким образом, что мне не важно, какую версию IP использовать. Ты можешь присвоить ей значение <tt class="const">AF_INET</tt> или
<tt class="const">AF_INET6</tt>, если хочешь использовать определённую версию.</p>

<p>Также, мы видим тут флаг <tt class="const">AI_PASSIVE</tt>; он говорит <b><tt class="func">getaddrinfo()</tt></b>, чтобы та присвоила адрес локального хоста структурам сокета. Это полезно, потому что тебе не нужно его хардкодить. (Или, ты можешь записать адрес в первый параметр <b><tt class="func">getaddrinfo()</tt></b>, там где сечас записан <tt class="const">NULL</tt>.)</p>

<p>Затем мы непосредственно выполняем вызов. Если произошла ошибка (<b><tt class="func">getaddrinfo()</tt></b> вернул не ноль), мы можем вывести её используя <b><tt class="func">gai_strerror()</tt></b>. Если же всё прошло как надо, <i><tt class="var">servinfo</tt></i> будет указывать на связный список из <nobr><tt class="type">struct addrinfo</tt></nobr>, каждый из которых содержит <nobr><tt class="type">struct
sockaddr</tt></nobr> некоторого вида, который мы сможем использовать позже! Ловкость рук и никакого мошенства!</p>

<p>Наконец, когда мы выполнили всю работу со связным списком, который <b><tt class="func">getaddrinfo()</tt></b> так любезно создал для нас, мы можем(и должны) очистить его, вызвав <b><tt class="func">freeaddrinfo()</tt></b>.</p>

<p>А вот пример вызова, если ты клиент, который хочет подсоединиться к определённому серверу, скажем "www.example.net", к порту 3490. Опять же, непосредственно соединения не произойдёт, но будут сформированы структуры, которые мы сможем использовать позднее:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

// get ready to connect
status = getaddrinfo("www.example.net", "3490", &amp;hints, &amp;servinfo);

// servinfo now points to a linked list of 1 or more struct addrinfos

// etc.</pre>


<p>Я не устану повторять, что <i><tt class="var">servinfo</tt></i> является связным списком со всеми видами информации о адресе. Давай напишем небольшую демо-программу, чтобы вывести эту информацию.  <a href="http://beej.us/guide/bgnet/examples/showip.c" target="_blank">Этот короткий код</a> выведет IP-адрес любого хоста, который ты можешь задать в консоли:</p>

<pre class="code">/*
** showip.c -- show IP addresses for a host given on the command line
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"usage: showip hostname\n");
        return 1;
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
        return 2;
    }

    printf("IP addresses for %s:\n\n", argv[1]);

    for(p = res;p != NULL; p = p-&gt;ai_next) {
        void *addr;
        char *ipver;

        // get the pointer to the address itself,
        // different fields in IPv4 and IPv6:
        if (p-&gt;ai_family == AF_INET) { // IPv4
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;
            addr = &amp;(ipv4-&gt;sin_addr);
            ipver = "IPv4";
        } else { // IPv6
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr;
            addr = &amp;(ipv6-&gt;sin6_addr);
            ipver = "IPv6";
        }

        // convert the IP to a string and print it:
        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);
        printf("  %s: %s\n", ipver, ipstr);
    }

    freeaddrinfo(res); // free the linked list

    return 0;
}</pre>


<p>Как ты можешь заметить, этот код вызывает <b><tt class="func">getaddrinfo()</tt></b> с аргументами, которые ты передашь через консоль, затем заполняет связный список, на который указывает <i><tt class="var">res</tt></i>, и после этого мы можем итерироваться по списку и выводить его значения или делать что-то другое.</p>

<p>(Тут есть довольно убогое место, где нам нужно выбрать тип <nobr><tt class="type">struct sockaddr</tt></nobr> в зависимости от версии IP. Прошу за это прощения! Не уверен, есть ли способ сделать это лучше..)</p>

<p>Пробный запуск! Все любят скриншоты:</p>

<pre class="screen">$ <b class="com">showip www.example.net</b>
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ <b class="com">showip ipv6.example.com</b>
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171</pre>


<p>Теперь, когда у нас всё под контролем, мы можем использовать результаты, полученные из <b><tt class="func">getaddrinfo()</tt></b>, передавая их в другие функции, связанные с сокетами и, наконец, установить стабильное соединение! Продолжай читать!</p>

 






<h3 class="sect2title">5.2. <a name="socket"><b><tt class="titlefunc">socket()</tt></b>—Получить файловый дескриптор!</a></h3>


<p>Кажется, я более не могу откладывать - я обязан рассказать о системном вызове <a name="indexId434909-92"></a><b><tt class="func">socket()</tt></b> system call. Вот его сигнатура:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol); 
</pre>


<p>Но что значат эти аргументы? Они позволяют тебе сказать, какой тип сокета ты хочешь (IPv4 или IPv6, потоковый или датаграм-сокет, TCP или UDP).</p>

<p>Раньше люди хардкодили эти значения, и это продолжается и поныне. (<i><tt class="var">domain</tt></i> может быть
<tt class="const">PF_INET</tt> или <tt class="const">PF_INET6</tt>, <i><tt class="var">type</tt></i>
- <tt class="const">SOCK_STREAM</tt> или <tt class="const">SOCK_DGRAM</tt>, а
<i><tt class="var">protocol</tt></i> может быть выставлен в <tt class="const">0</tt>, чтобы функция сама выбрала нужный протокол по данному <tt class="const">type</tt>. Или, ты можешь вызвать <b><tt class="func">getprotobyname()</tt></b>, чтобы получить имя протокола, который тебе нужен, "tcp" или "udp".)</p>

<p>(Константа <tt class="const">PF_INET</tt> - ближайшая родственница <a name="indexId434909-93"></a><tt class="const">AF_INET</tt>, которую ты можешь использовать для инициализации поля <i><tt class="var">sin_family</tt></i> в твоём <nobr><tt class="type">struct sockaddr_in</tt></nobr>.
На самом деле, они настолько близки, что даже имеют одно и то же значение и многие программисты вызывают <b><tt class="func">socket()</tt></b> и передают ему <tt class="const">AF_INET</tt> первым аргументом, вместо <b><tt class="func">PF_INET</tt></b>. А теперь, принеси ещё молока и печенек, потому что пришло время истории. Давным давно, считалось, что, возможно, семейство адресов ("AF" в "<tt class="const">AF_INET</tt>") сможет поддерживать различные протоколы, которые будут задаваться семейством протоколов ("PF" в "<tt class="const">PF_INET</tt>"). Но этого не случилось. И они жили долго и счастливо, Конец. Поэтому, наиболее правильно будет использовать <tt class="const">AF_INET</tt> в <nobr><tt class="type">struct sockaddr_in</tt></nobr> и <tt class="const">PF_INET</tt> при вызове <b><tt class="func">socket()</tt></b>.)</p>

<p>Впрочем, этого достаточно. Всё что тебе нужно сделать - это скормить значения, полученные из <b><tt class="func">getaddrinfo()</tt></b> функции <b><tt class="func">socket()</tt></b>, вот так:</p>

<pre class="code">int s;
struct addrinfo hints, *res;

// do the lookup
// [pretend we already filled out the "hints" struct]
getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

// [again, you should do error-checking on getaddrinfo(), and walk
// the "res" linked list looking for valid entries instead of just
// assuming the first one is good (like many of these examples do.)
// <a href="clientserver.html">See the section on client/server</a> for real examples.]

s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>


<p><b><tt class="func">socket()</tt></b> вернёт тебе <i>дескриптор сокета</i>, который ты сможешь использовать в дальнейших вызовах, или <tt class="const">-1</tt> в случае ошибки. Глобальная переменная <i><tt class="var">errno</tt></i> будет выставлена в значение ошибки (см. man-страницу <a href="errnoman.html"><i><tt class="var">errno</tt></i></a> для подробностей и небольшого замечания о том, как использовать <i><tt class="var">errno</tt></i> в многопоточных программах.)</p>

<p>Хорошо, хорошо, хорошо, но чем хорош этот сокет? Ответ: сам по себе ничем, но чтобы он стал полезен, нужно выполнить ещё несколько системных вызовов.</p>








<h3 class="sect2title">5.3. <a name="bind"><b><tt class="titlefunc">bind()</tt></b>—На каком порту я подвешен?</a></h3>


<p><a name="indexId434909-94"></a>После того, как ты получил сокет, возможно, ты захочешь подвесить его на <a name="indexId434909-95"></a>порт на твоём локальном компьютере. (Обычно это делается, если ты собираешься слушать (<a name="indexId434909-96"></a><b><tt class="func">listen()</tt></b>) приходящие соединения на определённом порту - многопользовательские игры делают это, когда говорят тебе "присоединиться к 192.168.5.10, порт 3490".)  Номер порта используется ядром, чтобы сопоставить приходящему пакету соответствующий дескриптор сокета. Если тебе нужно только подсоединиться (<a name="indexId434909-97"></a><b><tt class="func">connect()</tt></b>) (потому что ты клиент, а не сервер), это может быть не нужно. Тем не менее, советую прочитать этот раздел.</p>

<p>Вот так выглядит сигнатура системного вызова <b><tt class="func">bind()</tt></b>:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</pre>


<p><i><tt class="var">sockfd</tt></i> это файловый дескриптор сокета, полученный из <b><tt class="func">socket()</tt></b>.  <i><tt class="var">my_addr</tt></i>  - указатель на <nobr><tt class="type">struct sockaddr</tt></nobr>, которая содержит информацию о твоём адресе, то есть порт и  <a name="indexId434909-98"></a>IP-адрес.
<i><tt class="var">addrlen</tt></i> это длина этого адреса в байтах.</p>

<p>Фух. Тяжеловато впитать всё это в одном предложении. Рассмотрим пример, в котором подвесим сокет на хост, запускающий программу, порт 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p>Используя <tt class="const">AI_PASSIVE</tt> я говорю программе использовать IP хоста, на котором я запускаюсь. Если тебе нужно подвесить сокет на определённый локальный IP-адрес, выкинь <tt class="const">AI_PASSIVE</tt> и передай IP-адрес первым аргументом <b><tt class="func">getaddrinfo()</tt></b>.</p>

<p><b><tt class="func">bind()</tt></b> также возвращает <tt class="const">-1</tt> в случае ошибки и выставляет <i><tt class="var">errno</tt></i> в её значение.</p>

<p>Очень много старого кода вручную формирует <nobr><tt class="type">struct sockaddr_in</tt></nobr> перед вызовом <b><tt class="func">bind()</tt></b>. Очевидно, это относится к IPv4, но ничто не мешает тебе делать то же самое с IPv6, кроме факта, что использовать <b><tt class="func">getaddrinfo()</tt></b> гораздо проще. Тем не менее, старый код выглядел бы примерно так:</p>

<pre class="code">// !!! THIS IS THE OLD WAY !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);</pre>


<p>В вышеприведённом коде ты можешь также присвоить <tt class="const">INADDR_ANY</tt> полю <i><tt class="var">s_addr</tt></i>, если хочешь подвешиваться на локальный IP-адрес (точно так же, как используя флаг <tt class="const">AI_PASSIVE</tt>). IPv6-версия <tt class="const">INADDR_ANY</tt> - глобальная переменная <i><tt class="var">in6addr_any</tt></i>, которая присвоена в поле <i><tt class="var">sin6_addr</tt></i> твоего <nobr><tt class="type">struct sockaddr_in6</tt></nobr>.  (Также существует сокращение <tt class="const">IN6ADDR_ANY_INIT</tt>, которое ты можешь использовать для инициализации переменной.)</p>

<p>Ещё одна вещь, которую стоит учесть при вызове <b><tt class="func">bind()</tt></b>: не выбирать слишком низкие номера портов. <a name="indexId434909-99"></a> Все порты меньше 1024 ЗАРЕЗЕРВИРОВАНЫ (если конечно ты не суперпользователь)! Ты можешь использовать любой номер порта выше 1024, вплоть до 65535 (конечно, если этот номер не используется другой программой.)</p>

<p>Иногда, ты мог заметить, при попытке перезапуска сервера <b><tt class="func">bind()</tt></b> падает, утверждая, что <a name="indexId434909-100"></a>"Адрес уже занят." Что это значит? Ну, это значит, что в ядре есть сокет, который занимает этот порт. Ты можешь либо подождать, пока он освободится (примерно, минуту), или добавить в свою программу код, позволяющий переиспользовать порт, например, так:</p>

<pre class="code"><a name="indexId434909-101"></a><a name="indexId434909-102"></a>int yes=1;
//char yes='1'; // Solaris people use this

// lose the pesky "Address already in use" error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) == -1) {
    perror("setsockopt");
    exit(1);
} 
</pre>


<p><a name="indexId434909-103"></a>И ещё одно небольшое уточнение относительно <b><tt class="func">bind()</tt></b>: иногда, тебе необязательно вызывать его. Например, если ты <a name="indexId434909-104"></a><b><tt class="func">connect()</tt></b>ишься к удалённой машине и тебе нет дела до того, какой у тебя локальный порт (в случае, например, <b class="com">telnet</b> когда тебе важен только удалённый порт), ты можешь просто вызвать  <b><tt class="func">connect()</tt></b>, тот проверит, что сокет ни к чему не подвешен и подвесит (<b><tt class="func">bind()</tt></b>) его на свободный локальный порт при необходимости.</p>








<h3 class="sect2title">5.4. <a name="connect"><b><tt class="titlefunc">connect()</tt></b>—Эй, ты!</a></h3>


<p><a name="indexId434909-105"></a>Представь на минуту, что ты telnet-приложение. Пользователь приказывает тебе (прямо как в фильме <a name="indexId434909-106"></a><i>TRON</i>) 
получить файловый дескриптор сокета. Ты принимаешь приказ и вызываешь <b><tt class="func">socket()</tt></b>. Затем, пользователь говорит тебе связаться с "<tt class="tt">10.12.110.57</tt>", порт "<tt class="tt">23</tt>" (стандартный порт для протокола telnet port.) Ой! И что ты будешь делать теперь?</p>

<p>К счастью для тебя, программа, раздел который ты сейчас читаешь, о вызове <b><tt class="func">connect()</tt></b>—как соединиться с удалённым хостом. Поэтому яростно читай дальше! Нельзя терять ни минуты!</p>

<p>Сигнатура вызова <b><tt class="func">connect()</tt></b>:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> это наш дружелюбный файловый дескриптор, полученный из вызова <b><tt class="func">socket()</tt></b>, <i><tt class="var">serv_addr</tt></i> - это <nobr><tt class="type">struct sockaddr</tt></nobr>, содержащая информацию о IP-адресе и порте назначения, и наконец <i><tt class="var">addrlen</tt></i> - это длина в байтах адреса сервера.</p>

<p>Вся эта информация может быть получена в результате вызова <b><tt class="func">getaddrinfo()</tt></b>, и это реально круто.</p>

<p>Начинает проясняться? Я не могу тебя слышать отсюда, поэтому я просто буду надеяться, что это так. Давай рассмотрим пример, в котором мы соединим наш сокет с "www.example.com", порт 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p>Ещё раз, в старрых программах <nobr><tt class="type">struct
sockaddr_in</tt></nobr>ы заполняются вручную, чтобы передать их в <b><tt class="func">connect()</tt></b>. Если тебе тоже так хочется - можешь делать так. См. подобное замечание в секции <a href="syscalls.html#bind"><b><tt class="func">bind()</tt></b></a>, выше.</p>

<p>Не забудь проверить значение, которое вернул<b><tt class="func">connect()</tt></b> — он вернёт <tt class="const">-1</tt> в случае ошибки и присвоит <i><tt class="var">errno</tt></i> её код.</p>

<p><a name="indexId434909-107"></a>Также, обрати внимание, что мы не вызвали <b><tt class="func">bind()</tt></b>. Это потому, что нам наплевать, на каком локальном порту будет висеть наш сокет, нас заботит только удалённый порт, с которым нужно соединиться. Ядро автоматически выберет для нас локальный порт и сайт, с которым мы соединяемся, автоматически получит эту информацию. Так что волноваться не о чем.</p>








<h3 class="sect2title">5.5. <a name="listen"><b><tt class="titlefunc">listen()</tt></b>—Ну пожалуйста, свяжитесь со мной!</a></h3>


<p><a name="indexId434909-108"></a>Ok, пришло время изменить условия. Что если ты не хочешь связаться с удалённым хостом. Представь, что ты хочешь ждать входящих подключений и каким-то образом их обрабатывать. Этот процесс имеет две фазы: сначала необходимо вызвать <b><tt class="func">listen()</tt></b>, затем вызвать <a name="indexId434909-109"></a><b><tt class="func">accept()</tt></b> (см. ниже.)</p>

<p>Вызов <b><tt class="func">listen()</tt></b> довольно простой, но требует небольших объяснений:</p>

<pre class="code">int listen(int sockfd, int backlog); 
</pre>


<p><i><tt class="var">sockfd</tt></i> это обычный файловый дескриптор сокета, полученный из <b><tt class="func">socket()</tt></b>. <a name="indexId434909-110"></a><i><tt class="var">backlog</tt></i> - это размер очереди соединений. Что это значит? Всё просто: входящие соединения будут ждать в этой очереди пока ты не вызовешь для них <b><tt class="func">accept()</tt></b> (см. ниже) - и это число означает макимальное количество таких ожиданий. Большинство систем по-умолчанию ограничивают это число 20-ю; возможно, тебе захочется изменить это и установить его в <tt class="const">5</tt> или, скажем, <tt class="const">10</tt>.</p>

<p>И снова, как обычно, <b><tt class="func">listen()</tt></b> возвращает <tt class="const">-1</tt> в случае ошибки и устанавливает <i><tt class="var">errno</tt></i> в её код.</p>

<p>Возможно, ты догадываешься, что нам необходимо вызвать <b><tt class="func">bind()</tt></b> перед вызовом <b><tt class="func">listen()</tt></b>, указывая таким образом, что сервер запущен на определенном порту. (Ну ты же должен иметь возможность сказать своим приятелям к какому порту коннектиться!) Поэтому, если ты собираешься ожидать входящих подключений, последовательность вызовов будет такой:</p>

<pre class="code">getaddrinfo();
socket();
bind();
listen();
/* accept() goes here */ 
</pre>


<p>Я оставлю это в таком псевдокоде, потому что он вполне понятен. (Код в секции <b><tt class="func">accept()</tt></b>, ниже, гораздо более многословен.) По-настоящему хитрая часть всей этой магии, это вызов <b><tt class="func">accept()</tt></b>.</p>








<h3 class="sect2title">5.6. <a name="accept"><b><tt class="titlefunc">accept()</tt></b>—"Спасибо, что позвонили на порт 3490."</a></h3>


<p><a name="indexId434909-111"></a>Приготовься—вызов <b><tt class="func">accept()</tt></b> немного странный. Что должно произойти: кто-то далеко-далеко пытается соединиться(<b><tt class="func">connect()</tt></b>) с твоей машиной через порт, который ты сейчас слушаешь(<b><tt class="func">listen()</tt></b>). Соединение будет ожидать в очереди, пока ты его не примешь(<b><tt class="func">accept()</tt></b>). Ты вызываешь <b><tt class="func">accept()</tt></b>, и говоришь ему взять висящее соединение. Он вернёт тебе <i>совершенно новый файловый дескриптор сокета</i>, чтобы ты мог использовать его именно для этого соединения. Именно так, теперь у тебя есть <i>два файловых дескриптора сокета</i> по цене одного! Старый всё ещё ожидает новых подключений, а вновь созданный полностью готов к тому, чтобы посылать(<b><tt class="func">send()</tt></b>) и принимать(<b><tt class="func">recv()</tt></b>).  Вот и добрались! </p>

<p>Вызов выглядит так:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> - это сокетный дескриптор, слушающий порт. Пока всё просто. <i><tt class="var">addr</tt></i> обычно является указателем на локальный <nobr><tt class="type">struct sockaddr_storage</tt></nobr>. Это место, куда информация о входящих соединениях будет приходить (и именно оттуда ты можешь определить, какой же хост и с какого порта тебя вызывает). <i><tt class="var">addrlen</tt></i>  - локальная целочисленная переменная, которая должна быть установлена в <tt class="tt">sizeof(struct
sockaddr_storage)</tt> перед тем, как адрес хранилища будет передан в <b><tt class="func">accept()</tt></b>.  <b><tt class="func">accept()</tt></b> не будет пытаться положить большее число байт в <i><tt class="var">addr</tt></i>. Если он положит меньше, он отразит это изменением <i><tt class="var">addrlen</tt></i>.</p>

<p>Угадай, что? <b><tt class="func">accept()</tt></b> возвращает <tt class="const">-1</tt> и устанавливает в <i><tt class="var">errno</tt></i> код ошибки в случае таковой. Готов поспорить, ты и не подозревал об этом.</p>

<p>Как и в прошлых случаях, довольно тяжело понять это из одного предложения, поэтому вот тебе кусок кода для лучшего усвоения информации:</p>

<pre class="code">#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MYPORT "3490"  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue will hold

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! don't forget your error checking for these calls !!

    // first, load up address structs with getaddrinfo():

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

    // make a socket, bind it, and listen on it:

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    listen(sockfd, BACKLOG);

    // now accept an incoming connection:

    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    // ready to communicate on socket descriptor new_fd!
    .
    .
    .</pre>


<p>Теперь мы сможем использовать дескриптор сокета <i><tt class="var">new_fd</tt></i> для всех вызовов <b><tt class="func">send()</tt></b> и
<b><tt class="func">recv()</tt></b>. Если ты ждал единственного подключения, можешь закрыть (<b><tt class="func">close()</tt></b>) ожидающий <i><tt class="var">sockfd</tt></i>, чтобы предотвратить получение большего количества входящих соединений.</p>








<h3 class="sect2title">5.7. <a name="sendrecv"><b><tt class="titlefunc">send()</tt></b> и <b><tt class="titlefunc">recv()</tt></b>—Говори со мной, детка!</a></h3>


<p>Эти две функции нужны для связи через потоковые сокеты или соединённые датаграм-сокеты. Если ты хочешь использовать обычные датаграм-сокеты без соединения, см. раздел <a href="syscalls.html#sendtorecv"><b><tt class="func">sendto()</tt></b> и
<b><tt class="func">recvfrom()</tt></b></a>, ниже.</p>

<p><a name="indexId434909-112"></a>Вызов <b><tt class="func">send()</tt></b>:</p>

<pre class="code">int send(int sockfd, const void *msg, int len, int flags); 
</pre>


<p><i><tt class="var">sockfd</tt></i> - это файловый дескриптор сокета, которому ты собираешься послать данные (либо тот, что тебе вернул <b><tt class="func">socket()</tt></b>, либо полученный из вызова <b><tt class="func">accept()</tt></b>.) <i><tt class="var">msg</tt></i> - указатель на данные, которые ты собираешься послать, и <i><tt class="var">len</tt></i> - размер этих данных в байтах. <i><tt class="var">flags</tt></i> можно установить в <tt class="const">0</tt>.  (См. man - страницу <b><tt class="func">send()</tt></b> для большей информации о флагах.)</p>

<p>Код может быть примерно таким:</p>

<pre class="code">char *msg = "Beej was here!";
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
. 
</pre>


<p><b><tt class="func">send()</tt></b> возвращает количество байт, которое он отправил на самом деле—<i>это число может быть меньше того, что ты ему передал!</i>  Как видишь, иногда вызов не может полностью обработать большущий кусок данных, который ты ему передал. Он отправит столько, сколько сможет и будет рассчитывать, что ты попросишь его отправить остаток позже. Запомни, значение, которое возвращает <b><tt class="func">send()</tt></b> не обязательно совпадает со значением <i><tt class="var">len</tt></i>, и на тебе лежит ответственность за отправку оставшейся части строки. Хорошие новости: пакеты очень маленькие (менее 1K), поэтому, <i>возможно</i>, он сам отправит все данные за один вызов. И опять,  <tt class="const">-1</tt> возвращается в случае ошибки, <i><tt class="var">errno</tt></i> устанавливается в её код.</p>

<p><a name="indexId434909-113"></a>Вызов <b><tt class="func">recv()</tt></b> во многом похож на предыдущий:</p>

<pre class="code">int recv(int sockfd, void *buf, int len, int flags);</pre>


<p><i><tt class="var">sockfd</tt></i> - дескриптор сокета, из которого требуется читать, <i><tt class="var">buf</tt></i> - буфер, в который нужно сложить прочитанное, <i><tt class="var">len</tt></i> - максимальная длина буфера и <i><tt class="var">flags</tt></i> может снова быть установлен в <tt class="const">0</tt>.  (см. man <b><tt class="func">recv()</tt></b>.)</p>

<p><b><tt class="func">recv()</tt></b> возвращает количество байт, которые она прочитала в буфер, или <tt class="const">-1</tt> в случае ошибки( с изменением <i><tt class="var">errno</tt></i>, соответственно.)</p>

<p>Но подожди!  <b><tt class="func">recv()</tt></b> может вернуть <tt class="const">0</tt>. Это значит только одно - удалённая сторона закрыла ваше соединение. Возвращая <tt class="const">0</tt>, <b><tt class="func">recv()</tt></b> говорит тебе о том, что это произошло.</p>

<p>Было довольно просто, не так ли? Теперь ты можешь слать данные взад и вперёд через сокеты! Уииии! Теперь ты Программист Unix-Сетей!</p>








<h3 class="sect2title">5.8. <a name="sendtorecv"><b><tt class="titlefunc">sendto()</tt></b> и
<b><tt class="titlefunc">recvfrom()</tt></b>—Говори со мной в DGRAM-стиле!</a></h3>


<p><a name="indexId434909-114"></a>"Это всё хорошо и прекрасно," говоришь ты мне, "но что мне делать со всем этим, если у меня датаграм-сокеты без соединения?"  Но проблемо, амиго. Нужно упомянуть всего лишь одну вещь.</p>

<p>Поскольку датаграм-сокеты не соединены с удалённым хостом, угадай, какая информация нам нужна перед тем, как послать пакет? Правильно! Адрес назначения! Вот так это выглядит:</p>

<pre class="code">int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen); </pre>


<p>Как ты можешь заметить, этот вызов очень похож на <b><tt class="func">send()</tt></b> с добавлением ещё двух переменных с информацией. <i><tt class="var">to</tt></i> - это указатель на <nobr><tt class="type">struct
sockaddr</tt></nobr> (который может являться ещё одним <nobr><tt class="type">struct
sockaddr_in</tt></nobr>, или <nobr><tt class="type">struct sockaddr_in6</tt></nobr>, или <nobr><tt class="type">struct
sockaddr_storage</tt></nobr>, который тебе необходимо привести к нужному типу в последний момент), который содержит <a name="indexId434909-115"></a>IP-адрес и <a name="indexId434909-116"></a>порт назначения.
<i><tt class="var">tolen</tt></i>, на самом деле <nobr><tt class="type">int</tt></nobr>, может просто быть установлен в <tt class="tt">sizeof *to</tt> или <tt class="tt">sizeof(struct sockaddr_storage)</tt>.</p>

<p>Чтобы достать адрес получателя, тебе необходимо либо вызвать <b><tt class="func">getaddrinfo()</tt></b>, либо получить его из <b><tt class="func">recvfrom()</tt></b>, ниже, либо придётся заполнять вручную.</p>

<p>Как и в случае <b><tt class="func">send()</tt></b>, <b><tt class="func">sendto()</tt></b> возвращает число переданных байт (которое, опять же, может быть меньше, чем число, которое ты ему передал!), или <tt class="const">-1</tt> в случае ошибки.</p>

<p>Точно так же похожи и <b><tt class="func">recv()</tt></b> и
<a name="indexId434909-117"></a><b><tt class="func">recvfrom()</tt></b>. Сигнатура <b><tt class="func">recvfrom()</tt></b> такова:</p>

<pre class="code">int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen); </pre>


<p>И снова, совсем как <b><tt class="func">recv()</tt></b> плюс несколько дополнительных полей: <i><tt class="var">from</tt></i> это указатель на локальный <a name="indexId434909-118"></a><nobr><tt class="type">struct sockaddr_storage</tt></nobr>, который будет заполнен IP-адресом и портом отправителя. <i><tt class="var">fromlen</tt></i> - указатель на локальный <nobr><tt class="type">int</tt></nobr>, который должен быть инициализирован <tt class="tt">sizeof *from</tt> или
<tt class="tt">sizeof(struct sockaddr_storage)</tt>. После возврата из функции, <i><tt class="var">fromlen</tt></i> будет содержать 
длину адреса, который на самом деле был сохранён в <i><tt class="var">from</tt></i>.</p>

<p><b><tt class="func">recvfrom()</tt></b> возвращает количество полученных байт или <tt class="const">-1</tt> при ошибке (и устанавливает <i><tt class="var">errno</tt></i>, соответственно.)</p>

<p>Но вот вопрос: почему мы используем <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> как тип сокета? Почему не <nobr><tt class="type">struct
sockaddr_in</tt></nobr>?  Потому что, таким образом мы не привязываемся к IPv4 или IPv6. Поэтому мы используем более общий
 <nobr><tt class="type">struct sockaddr_storage</tt></nobr>, о котором мы знаем, что тот достаточно большой, чтобы использовать его в обоих случаях.</p>

<p>(Только... вот ещё вопрос: а почему <nobr><tt class="type">struct
sockaddr</tt></nobr> недостаточно велик для любого адреса? Нам даже приходится кастить независимый от версии <nobr><tt class="type">struct sockaddr_storage</tt></nobr> к независимому от версии <nobr><tt class="type">struct sockaddr</tt></nobr>! Выглядит странно и излишне! Ответ заключается в том, что он просто оказался недостаточно велик, а менять его, когда это обнаружилось, было бы Проблематично. Поэтому, они создали новый.)</p>

<p>Помни, что если ты подсоединился(<a name="indexId434909-119"></a><b><tt class="func">connect()</tt></b>) к датаграм-сокету, ты можешь просто использовать  <b><tt class="func">send()</tt></b> и
<b><tt class="func">recv()</tt></b> для общения. Сокет будет оставаться датаграм-сокетом и пакеты будут всё ещё использовать UDP, но интерфейс сокета будет автоматически добавлять информацию о отправителе и получателе за тебя.</p>










<h3 class="sect2title">5.9. <a name="closedown"><b><tt class="titlefunc">close()</tt></b> and
<b><tt class="titlefunc">shutdown()</tt></b>—Убирайся с глаз моих!</a></h3>


<p>Фух! Ты отправлял и получал данные целый день и наконец-то закончил. Теперь ты готов к тому, чтобы закрыть дескриптор сокета.
Это просто. Ты можешь использовать стандартную функцию Unix, закрывающую файловый дескриптор- 
<a name="indexId434909-120"></a><b><tt class="func">close()</tt></b>:</p>

<pre class="code">close(sockfd); 
</pre>


<p>Это предотвратит последующее чтение из и запись в сокет. Если кто-то попытается что-то прочитать из или записать в сокет удалённо, он получит ошибку.</p>

<p>На всякий случай, если ты хочешь чуть больше контроля над тем, как сокет закрывается, ты можешь использовать вызов <a name="indexId434909-121"></a><b><tt class="func">shutdown()</tt></b>. Он позволяет тебе прервать коммуникацию в определённом направлении, или в обе стороны (точно так же, как это делает <b><tt class="func">close()</tt></b>.)
Сигнатура:</p>

<pre class="code">int shutdown(int sockfd, int how); 
</pre>


<p><i><tt class="var">sockfd</tt></i>  - это файловый дескриптор сокета, который ты хочешь закрыть, и <i><tt class="var">how</tt></i> - это одно значение из следующих:</p>

<p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="10%%"><p><tt class="const">0</tt></p></td>
<td valign="top" align="left" width="88%%"><p>Последующее получение данных запрещено</p></td>
</tr>

<tr><td valign="top" align="left"><p><tt class="const">1</tt></p></td>
<td valign="top" align="left"><p>Последующая отправка данных запрещена</p></td>
</tr>

<tr><td valign="top" align="left"><p><tt class="const">2</tt></p></td>
<td valign="top" align="left"><p>Последующее получение и отправка данных запрещены (работает так же, как <b><tt class="func">close()</tt></b>)</p></td>
</tr>

</table></center>
</p>

<p><b><tt class="func">shutdown()</tt></b> возвращает <tt class="const">0</tt> в случае успеха, или <tt class="const">-1</tt> в случае 
ошибки (+устанавливает соответствующий<i><tt class="var">errno</tt></i>.)</p>

<p>Если же ты снизошёл до того, чтобы вызвать <b><tt class="func">shutdown()</tt></b> на датаграм-сокете без соединения, он просто сделает сокет недоступным для последующих <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> 
(помни, что ты можешь использовать эти вызовы, если ты вызвал <b><tt class="func">connect()</tt></b>
на своём датаграм-сокете.)</p>

<p>Важно отметить, что <b><tt class="func">shutdown()</tt></b> на самом деле не закрывает файловый дескриптор, а просто запрещает его 
использование. Чтобы освободить дескриптор сокета, необходимо вызвать <b><tt class="func">close()</tt></b>.</p>

<p>Вот и всё.</p>

<p>(Кроме небольшого замечания, что если ты используешь <a name="indexId434909-122"></a>Windows
и <a name="indexId434909-123"></a>Winsock, тебе нужно вызвать <a name="indexId434909-124"></a><b><tt class="func">closesocket()</tt></b> вместо <b><tt class="func">close()</tt></b>.)</p>









<h3 class="sect2title">5.10. <a name="getpeername"><b><tt class="titlefunc">getpeername()</tt></b>—Кто ты?</a></h3>


<p><a name="indexId434909-125"></a>Эта функция очень простая.</p>

<p>Она настолько простая, что я не хотел выделять ей отдельный раздел. Но, всё же, вот он.</p>

<p>Функция <b><tt class="func">getpeername()</tt></b> может сказать тебе, кто же находится на другом конце соединённого потокового сокета. Сигнатура:</p>

<pre class="code">#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> это дескриптор соединённого потокового сокета, <i><tt class="var">addr</tt></i> - это указатель на <nobr><tt class="type">struct sockaddr</tt></nobr> (или <nobr><tt class="type">struct sockaddr_in</tt></nobr>), который будет содержать информацию о другой стороне соединения, и <i><tt class="var">addrlen</tt></i> это указатель на <nobr><tt class="type">int</tt></nobr>, который должен быть инициализирован <tt class="tt">sizeof *addr</tt> или <tt class="tt">sizeof(struct
sockaddr)</tt>.</p>

<p>Функция возвращает <tt class="const">-1</tt> в случае ошибки и устанавливает
<i><tt class="var">errno</tt></i> соттветственно.</p>

<p>Теперь, когда ты получил адрес собеседника, ты можешь использовать <a name="indexId434909-126"></a><b><tt class="func">inet_ntop()</tt></b>, <a name="indexId434909-127"></a><b><tt class="func">getnameinfo()</tt></b>, или <a name="indexId434909-128"></a><b><tt class="func">gethostbyaddr()</tt></b>, чтобы вывести или получить больше информации. Нет, ты не можешь получить его логин. (Хорошо, хорошо. Если на другом компьютере запущен ident-демон, это возможно. Но это уже совсем другая история. см.  <a href="http://tools.ietf.org/html/rfc1413" target="_blank">RFC 1413</a> для большей информации.)</p>









<h3 class="sect2title">5.11. <a name="gethostname"><b><tt class="titlefunc">gethostname()</tt></b>—Кто я?</a></h3>


<p><a name="indexId434909-129"></a>Ещё более простой, чем <b><tt class="func">getpeername()</tt></b>, является функция
 <b><tt class="func">gethostname()</tt></b>. Она возвращает имя компьютера, на котором запущена текущая программа. 
 Это имя, к примеру, может быть использовано 
<a name="indexId434909-130"></a><b><tt class="func">gethostbyname()</tt></b>, далее, чтобы определить 
 <a name="indexId434909-131"></a>IP-адрес локальной машины.</p>

<p>Что может быть ещё более весёлым? Есть у меня пара идей, правда они не имеют отношения к программированию на сокетах. 
Вот сигнатура функции:</p>

<pre class="code">#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size); 
</pre>


<p>Аргументы просты: <i><tt class="var">hostname</tt></i> это указатель на массив символов, который будет содержать адрес хоста 
после возврата из функции, и <i><tt class="var">size</tt></i> - это длина в байтах массива <i><tt class="var">hostname</tt></i>.</p>

<p>Функция возвращает <tt class="const">0</tt> в случае успеха, и <tt class="const">-1</tt> в случае ошибки, устанавливая <i><tt class="var">errno</tt></i>, как обычно.</p>



<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="ip4to6.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="clientserver.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>

</body>
</html>
