<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Client-Server Background</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="syscalls.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="advanced.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>


<h2 class="sect1title">6. <a name="clientserver">Взаимосвязь Клиент-Сервер</a></h2><hr class="mainsecthr"/>


<p><a name="indexId434909-132"></a>Это клиент-серверный мир, детка. Почти всё в сети работает через клиентские процессы, общающиеся с серверными и наоборот. Возьмём, к примеру, <b class="com">telnet</b>. Когда ты подсоединяешься к удалённому хосту через порт 23 по telnet
(клиент), программа на той стороне (<b class="com">telnetd</b>, сервер) пробуждается ото сна. Она обрабатывает входящее telnet-соединение, спрашивает у тебя логин и т.д.</p>

<a name="figure2" /><center>
    <div><img src="cs-120-3.334.png" alt="[Client-Server Interaction Diagram]"/></div>

    <p><b>Общение между Сервером и Клиентом.</b></p>
</center>


<p>Обмен информацией между клиентом и сервером я схематически изобразил в <a href="clientserver.html#figure2">этой диаграмме</a>.</p>

<p>Учти, что пара клиент-сервер может общаться через <tt class="const">SOCK_STREAM</tt>, <tt class="const">SOCK_DGRAM</tt>, или
через что угодно (до тех пор, пока они используют одно и то же.) Несколько хороших примеров клиент-серверных пар, это 
<b class="com">telnet</b>/<b class="com">telnetd</b>,
<b class="com">ftp</b>/<b class="com">ftpd</b>, или
<b class="com">Firefox</b>/<b class="com">Apache</b>.  Каждый раз, когда ты используешь
<b class="com">ftp</b>, есть удалённая программа,
<b class="com">ftpd</b>, которая обслуживает твои запросы.</p>

<p>Довольно часто, на машине работает только один сервер, и этот сервер обрабатывает множество клиентов, используя <a name="indexId434909-133"></a><b><tt class="func">fork()</tt></b>. Типичная последовательность действий: сервер ждёт соединения, <b><tt class="func">accept()</tt></b>ит его, и <b><tt class="func">fork()</tt></b>ается, создавая дочерний процесс, обрабатывающий это соединение. Так работает наш простой сервер, описанный в следующем разделе.</p>







<h3 class="sect2title">6.1. <a name="simpleserver">Простой потоковый сервер</a></h3>


<p><a name="indexId434909-134"></a>Всё, что делает этот сервер - это отправляет строку
"<tt class="tt">Hello, World!\n</tt>" через потоковое соединение. Все, что тебе нужно, чтобы протестировать этот сервер - это 
запустить его в отдельном окне и отправить ему telnet - запрос из другого вот так:</p>

<pre class="screen">$ telnet remotehostname 3490</pre>


<p>where <tt class="tt">remotehostname</tt> - это имя компьютера, на которой ты в данный момент запускаешь всё это.</p>

<p><a href="http://beej.us/guide/bgnet/examples/server.c" target="_blank">Код сервера</a>:</p>

<pre class="code">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT "3490"  // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

void sigchld_handler(int s)
{
    while(waitpid(-1, NULL, WNOHANG) &gt; 0);
}

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("server: socket");
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror("setsockopt");
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("server: bind");
            continue;
        }

        break;
    }

    if (p == NULL)  {
        fprintf(stderr, "server: failed to bind\n");
        return 2;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    printf("server: waiting for connections...\n");

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror("accept");
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf("server: got connection from %s\n", s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, "Hello, world!", 13, 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}</pre>


<p>Если тебе интересно, я положил весь код в одну большую функцию <b><tt class="func">main()</tt></b>, чтобы это всё (как мне кажется) 
выглядело синтаксически чисто. Ты можешь разделить функционал на функции поменьше, если тебе так удобнее.</p>

<p>(Также, функция <a name="indexId434909-135"></a><b><tt class="func">sigaction()</tt></b>
может быть нова для тебя - это норма. Вышеописанный код убивает <a name="indexId434909-136"></a>процессы-зомби, которые появляются после 
завершения <b><tt class="func">fork()</tt></b>нутого дочернего процесса. Если ты насоздаёшь много зомби и не убьёшь их, это заставит системного администратора поволноваться.)</p>

<p>Ты можешь получить данные из этого сервера используя клиент, описанный в следующем разделе.</p>





<h3 class="sect2title">6.2. <a name="simpleclient">Простой потоковый клиент</a></h3>


<p><a name="indexId434909-137"></a>Этот парень ещё проще, чем сервер. Всё, что делает клиент - это соединяется с хостом, заданным 
через консоль, порт 3490 и получает строку, которую ему отправляет сервер.</p>

<p><a href="http://beej.us/guide/bgnet/examples/client.c" target="_blank">Исходник клиента</a>:</p>

<pre class="code">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT "3490" // the port client will be connecting to 

#define MAXDATASIZE 100 // max number of bytes we can get at once 

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"usage: client hostname\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("client: socket");
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("client: connect");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "client: failed to connect\n");
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf("client: connecting to %s\n", s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf("client: received '%s'\n",buf);

    close(sockfd);

    return 0;
}</pre>


<p>Обрати внимание, что если ты запустишь клиент до запуска сервера, <b><tt class="func">connect()</tt></b> вернёт
<a name="indexId434909-138"></a>"Connection refused". Это весьма полезно.</p>









<h3 class="sect2title">6.3. <a name="datagram">Датаграм-сокеты</a></h3>


<p>Мы уже рассмотрели основы UDP-датаграм сокетов, когда обсуждали 
 <b><tt class="func">sendto()</tt></b> и <b><tt class="func">recvfrom()</tt></b> выше, поэтому я просто покажу парочку простых программ:
 <i><tt class="var">talker.c</tt></i>
и <i><tt class="var">listener.c</tt></i>.</p>

<p><a name="indexId434909-139"></a><b class="com">listener</b> висит на машине и ожидает входящих пакетов на порту 4950.
 <b class="com">talker</b> отправляет пакет на этот порт, на определённую машину, содержащий то, что пользователь ввёл в командной строке.</p>

<p>Вот <a href="http://beej.us/guide/bgnet/examples/listener.c" target="_blank">исходник <i><tt class="var">listener.c</tt></i></a>:</p>

<pre class="code">/*
** listener.c -- a datagram sockets "server" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT "4950"    // the port users will be connecting to

#define MAXBUFLEN 100

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;
    struct sockaddr_storage their_addr;
    char buf[MAXBUFLEN];
    socklen_t addr_len;
    char s[INET6_ADDRSTRLEN];

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // set to AF_INET to force IPv4
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("listener: socket");
            continue;
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("listener: bind");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "listener: failed to bind socket\n");
        return 2;
    }

    freeaddrinfo(servinfo);

    printf("listener: waiting to recvfrom...\n");

    addr_len = sizeof their_addr;
    if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
        (struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("listener: got packet from %s\n",
        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s));
    printf("listener: packet is %d bytes long\n", numbytes);
    buf[numbytes] = '\0';
    printf("listener: packet contains \"%s\"\n", buf);

    close(sockfd);

    return 0;
}</pre>


<p>Обрати внимание, что в нашем вызове <b><tt class="func">getaddrinfo()</tt></b> мы используем <tt class="const">SOCK_DGRAM</tt>. 
Также, заметь, что нет нужды вызывать <b><tt class="func">listen()</tt></b> или <b><tt class="func">accept()</tt></b>. Это одно из удобств использования датаграм-сокетов без соединения!</p>

<p><a name="indexId434909-140"></a>Теперь пришло время <a href="http://beej.us/guide/bgnet/examples/talker.c" target="_blank">исходника <i><tt class="var">talker.c</tt></i></a>:</p>


<pre class="code">/*
** talker.c -- a datagram "client" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT "4950"    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;

    if (argc != 3) {
        fprintf(stderr,"usage: talker hostname message\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;

    if ((rv = getaddrinfo(argv[1], SERVERPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and make a socket
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("talker: socket");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "talker: failed to bind socket\n");
        return 2;
    }

    if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
             p-&gt;ai_addr, p-&gt;ai_addrlen)) == -1) {
        perror("talker: sendto");
        exit(1);
    }

    freeaddrinfo(servinfo);

    printf("talker: sent %d bytes to %s\n", numbytes, argv[1]);
    close(sockfd);

    return 0;
}</pre>



<p>Вот и всё! Запусти <b class="com">listener</b> на одной машине, затем запусти <b class="com">talker</b> на другой и смотри, как 
они общаются! Развлечение для всех возрастов!</p>

<p>В этот раз тебе даже не нужно запускать сервер! Можешь запустить <b class="com">talker</b>а самого по себе, и он будет беззаботно 
отсылать пакеты в никуда, где они будут исчезать, пока на той стороне не вызовут 
<b><tt class="func">recvfrom()</tt></b>. Но помни: данные, посланные через UDP, могут не дойти!</p>

<p>Если конечно ты не используешь одну маленькую деталь, которую я не раз упоминал в прошлом: <a name="indexId434909-141"></a> датаграм - 
сокеты с соединением. Нужно поговорить об этом, раз уж речь зашла о датаграм-сокетах. Пусть, скажем, <b class="com">talker</b> вызовет
<b><tt class="func">connect()</tt></b> и даст на вход адрес <b class="com">listener</b>'а.
После этого, <b class="com">talker</b> может отсылать и принимать данные исключительно по адресу, заданному в <b><tt class="func">connect()</tt></b>. По этой причине, тебе не обязательно использовать <b><tt class="func">sendto()</tt></b> и <b><tt class="func">recvfrom()</tt></b>; ты можешь просто использовать <b><tt class="func">send()</tt></b> и <b><tt class="func">recv()</tt></b>.</p>



<table width="100%" border="0" cellspacing="0"cellpadding="0" class="navtable">
<tr>
<td align="left"><a href="syscalls.html">&lt;&lt;&nbsp;Пред</a></td>
<td align="center"><a href="index.html">Руководство Beej'a по Программированию Сетей</a></td><td align="right"><a href="advanced.html">След&nbsp;&gt;&gt;</a></td>
</tr></table>

</body>
</html>
